[
  {
    "objectID": "figures/fastercap-maxwell-capacitance-matrix-schematic.html",
    "href": "figures/fastercap-maxwell-capacitance-matrix-schematic.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Figure 1: Schematic representation of the MOM capacitor."
  },
  {
    "objectID": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_overlap.html",
    "href": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_overlap.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Overlap capacitances to substrate."
  },
  {
    "objectID": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_sidewall.html",
    "href": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_sidewall.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Sidewall capacitance between nets A and B on li1."
  },
  {
    "objectID": "figures/test_patterns/r_contact_1x1_minsize_mcon.html",
    "href": "figures/test_patterns/r_contact_1x1_minsize_mcon.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Resistance of a minimum sized via on mcon."
  },
  {
    "objectID": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_m1_li1.html",
    "href": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_m1_li1.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Fringe capacitances m1 to li1."
  },
  {
    "objectID": "figures/test_patterns/r_contact_2x2_minsize_mcon.html",
    "href": "figures/test_patterns/r_contact_2x2_minsize_mcon.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Resistance of a minimum sized 2x2 via on mcon."
  },
  {
    "objectID": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_overlap.html",
    "href": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_overlap.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Overlap capacitance of nets on li1."
  },
  {
    "objectID": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_li1_substrate.html",
    "href": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_li1_substrate.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Fringe capacitances li1 to substrate."
  },
  {
    "objectID": "notebooks/ticer_example_bode_plots.html",
    "href": "notebooks/ticer_example_bode_plots.html",
    "title": "TICER Example: Bode Plots",
    "section": "",
    "text": "Copyright 2025 Martin Köhler\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0"
  },
  {
    "objectID": "notebooks/ticer_example_bode_plots.html#original-versus-reduced-circuit",
    "href": "notebooks/ticer_example_bode_plots.html#original-versus-reduced-circuit",
    "title": "TICER Example: Bode Plots",
    "section": "Original versus reduced circuit",
    "text": "Original versus reduced circuit\nThe original transfer function is:\n\\[\nH(s) = \\frac{1}{0.01s^3 + 2.03s^2 + 4.02s + 1}\n\\]\nThe reduced transfer function is \\[\nH(s) = \\frac{0.5}{1.010025s^2 + 2.01s + 0.5}\n\\]\nas obtained by:\n\nfrom sympy import symbols, Matrix, simplify, roots\nimport pprint\n\ns = symbols('s')  # Define the Laplace variable 's'\n\n# Define the matrix A(s) = s*C + G\nA_orig = Matrix([\n    [s + 2,     0,           -1],\n    [    0, s + 1,           -1],\n    [   -1,    -1, 0.01 * s + 2]\n])\n\nA_reduced = Matrix([\n    [s * 1.005 + 1 + 0.5,            -0.5],\n    [               -0.5, s * 1.005 + 0.5]\n])\n\ndef solve(A: Matrix, \n          voltage_row_index: int, \n          current_index: int) -&gt; dict:\n    \"\"\"\n    Computes the transfer function H(s) = V_out(s) / J_in(s) for a given system matrix A(s),\n    where V_out(s) is the output voltage and J_in(s) is the input current.\n\n    Parameters:\n    ----------\n    A: Matrix\n        The system matrix in the Laplace domain\n    voltage_row_index: int\n        The row index of the inverse matrix A(s)^-1 corresponding to the desired output voltage.\n        For example:\n        - 0 for V_1(s)\n        - 1 for V_2(s)\n        - 2 for V_3(s)\n    current_index: int\n        The column index of the input vector corresponding to the input current.\n        For example:\n        - 0 for J_1(s)\n        - 1 for J_2(s)\n        - 2 for J_3(s)\n\n    Returns:\n    -------\n    dict\n        A dictionary containing:\n        - \"transfer_function\": The symbolic transfer function H(s).\n        - \"poles\": The poles of the transfer function (roots of the denominator).\n        - \"zeros\": The zeros of the transfer function (roots of the numerator).\n        - \"determinant\": The determinant of A(s).\n        - \"adjugate\": The adjugate matrix of A(s).\n        - \"selected_row\": The selected row of A(s)^-1 corresponding to the output voltage.\n        - \"input_vector\": The input vector used in the computation.\n    \"\"\"\n    det_A = A.det()  # Compute the determinant of A(s)\n    det_A_simplified = simplify(det_A)  # Simplify the determinant    \n\n    adj_A = A.adjugate()  # Compute the adjugate matrix of A(s)\n\n    A_inv = adj_A / det_A_simplified  # Compute the inverse of A(s) symbolically\n\n    # Extract the second row of A_inv (e.g., 1 corresponds to V_2(s))\n    selected_row_A_inv = A_inv.row(voltage_row_index)\n\n    # Define the input vector [J_1(s), 0, 0]\n    input_vector = Matrix([1 if i == current_index else 0 for i in range(A.shape[0])])\n\n    # Compute V_2(s) as the dot product of the second row of A_inv and the input vector\n    V_out_s = simplify(selected_row_A_inv.dot(input_vector))\n\n    H_s = V_out_s  # Define the transfer function H(s) = V_out(s) / J_in(s)\n\n    poles = roots(det_A_simplified, s)\n    numerator = simplify(V_out_s.as_numer_denom()[0])\n\n    zeros = roots(numerator, s)\n\n    return {\n        'transfer_function': H_s,\n        'poles': poles,\n        'zeros': zeros,\n        'determinant': det_A_simplified,\n        'adjugate': adj_A,\n        'selected_row': selected_row_A_inv,\n        'input_vector': input_vector\n    }\n\nsolution_orig = solve(A=A_orig, voltage_row_index=1, current_index=0)\nsolution_redux = solve(A=A_reduced, voltage_row_index=1, current_index=0)\n\npprint.pprint(f\"Solution for the original circuit: {solution_orig}\\n\")\npprint.pprint(f\"Solution for the reduced circuit: {solution_redux}\\n\")\n\n(\"Solution for the original circuit: {'transfer_function': 1/(0.01*s**3 + \"\n \"2.03*s**2 + 4.02*s + 1), 'poles': {-201.002500000000: 1, -1.70585346667118: \"\n \"1, -0.291646533329211: 1}, 'zeros': {}, 'determinant': 0.01*s**3 + 2.03*s**2 \"\n \"+ 4.02*s + 1, 'adjugate': Matrix([\\n\"\n '[0.01*s**2 + 2.01*s + 1,                      1,          s + 1],\\n'\n '[                     1, 0.01*s**2 + 2.02*s + 3,          s + 2],\\n'\n '[                 s + 1,                  s + 2, s**2 + 3*s + 2]]), '\n \"'selected_row': Matrix([[1/(0.01*s**3 + 2.03*s**2 + 4.02*s + 1), (0.01*s**2 \"\n '+ 2.02*s + 3)/(0.01*s**3 + 2.03*s**2 + 4.02*s + 1), (s + 2)/(0.01*s**3 + '\n \"2.03*s**2 + 4.02*s + 1)]]), 'input_vector': Matrix([\\n\"\n '[1],\\n'\n '[0],\\n'\n '[0]])}\\n')\n(\"Solution for the reduced circuit: {'transfer_function': 0.5/(1.010025*s**2 + \"\n \"2.01*s + 0.5), 'poles': {-1.69861371262343: 1, -0.291436038620351: 1}, \"\n \"'zeros': {}, 'determinant': 1.010025*s**2 + 2.01*s + 0.5, 'adjugate': \"\n 'Matrix([\\n'\n '[1.005*s + 0.5,           0.5],\\n'\n \"[          0.5, 1.005*s + 1.5]]), 'selected_row': \"\n 'Matrix([[0.5/(1.010025*s**2 + 2.01*s + 0.5), (1.005*s + 1.5)/(1.010025*s**2 '\n \"+ 2.01*s + 0.5)]]), 'input_vector': Matrix([\\n\"\n '[1],\\n'\n '[0]])}\\n')\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import TransferFunction, bode\n\n# Generate frequency responses\n\nfreq_range = np.logspace(-2, 3, 500)  # Frequency range from 10^-2 to 10^2 rad/s\nw1, mag1, phase1 = bode(\n    TransferFunction(\n       [1],                     # H(s) numerator\n       [0.01, 2.03, 4.02, 1.0]  # H(s) denominator\n    ), \n    w=freq_range\n)\n\nw2, mag2, phase2 = bode(\n    TransferFunction(\n       [0.5],                   # H(s) numerator\n       [1.010025, 2.01, 0.5]  # H(s) denominator\n    ),\n    w=freq_range\n)\n\n\n# Plot fT versus Magnitude\n#| label: fig-bode-plot-ft-vs-mag\n#| fig-cap: Bode plot: Frequency versus Magnitude\nplt.figure(figsize=(10, 3))\nplt.semilogx(w1, mag1, label='Original circuit (blue)')  # Bode magnitude plot\nplt.semilogx(w2, mag2, color='red', linestyle=':', label='Reduced circuit (red)')  # Bode magnitude plot\nplt.title('Bode Plot - Magnitude')\nplt.xlabel('Frequency (rad/s)')\nplt.ylabel('Magnitude (dB)')\nplt.grid(which='both', linestyle='--', linewidth=0.5)\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n# Plot fT versus phase\n#| label: fig-bode-plot-ft-vs-phase\n#| fig-cap: Bode plot: Frequency versus Phase\nplt.figure(figsize=(10, 3))\nplt.semilogx(w1, phase1, label='Original circuit (blue)')  # Bode phase plot\nplt.semilogx(w2, phase2, color='red', linestyle=':', label='Reduced circuit (red)')  # Bode phase plot\nplt.title('Bode Plot - Phase')\nplt.xlabel('Frequency (rad/s)')\nplt.ylabel('Phase (degrees)')\nplt.grid(which='both', linestyle='--', linewidth=0.5)\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\nPole-Zero plots\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_poles_and_zeros(poles, zeros):\n    \"\"\"\n    Plots the poles and zeros of a transfer function on the complex plane.\n\n    Parameters:\n    ----------\n    poles : list or dict\n        A list or dictionary of poles (roots of the denominator). If it's a dictionary,\n        the keys are the poles, and the values are their multiplicities.\n    zeros : list or dict\n        A list or dictionary of zeros (roots of the numerator). If it's a dictionary,\n        the keys are the zeros, and the values are their multiplicities.\n\n    Returns:\n    -------\n    None\n    \"\"\"\n    # Convert poles and zeros to lists if they are dictionaries\n    if isinstance(poles, dict):\n        poles = list(poles.keys())\n    if isinstance(zeros, dict):\n        zeros = list(zeros.keys())\n\n    # Convert symbolic poles and zeros to Python complex numbers\n    poles = [complex(p.evalf()) for p in poles]\n    zeros = [complex(z.evalf()) for z in zeros]\n\n    # Separate real and imaginary parts for poles and zeros\n    poles_real = [p.real for p in poles]\n    poles_imag = [p.imag for p in poles]\n    zeros_real = [z.real for z in zeros]\n    zeros_imag = [z.imag for z in zeros]\n\n    # Create the plot\n    plt.figure(figsize=(8, 6))\n    plt.axhline(0, color='black', linewidth=0.5, linestyle='--')  # Horizontal axis\n    plt.axvline(0, color='black', linewidth=0.5, linestyle='--')  # Vertical axis\n\n    # Plot poles and zeros\n    plt.scatter(poles_real, poles_imag, marker='x', color='red', label='Poles', s=100)\n    plt.scatter(zeros_real, zeros_imag, marker='o', color='blue', label='Zeros', s=100)\n\n    # Add labels and grid\n    plt.title(\"Pole-Zero Plot\")\n    plt.xlabel(\"Real Part\")\n    plt.ylabel(\"Imaginary Part\")\n    plt.grid(True, linestyle='--', alpha=0.7)\n    plt.legend()\n    plt.axis('equal')  # Equal scaling for real and imaginary axes\n\n    # Show the plot\n    plt.show()\n\n\n# Pole-Zero Plot for the original circuit\n#| label: fig-pole-zero-plot-original\n#| fig-cap: Pole-Zero plot: Original circuit\n\nplot_poles_and_zeros(poles=solution_orig['poles'],\n                     zeros=solution_orig['zeros'])\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\nIf we remove the node at \\(s=201\\) we get better scaling for comparison.\n\n# Pole-Zero Plot for the original circuit (without the pole at s=201)\n#| label: fig-pole-zero-plot-original-without-201\n#| fig-cap: Pole-Zero plot: Original circuit (without the pole at $s = 201$)\npoles = dict(list(solution_orig['poles'].items())[1:])\nplot_poles_and_zeros(poles=poles,\n                     zeros=solution_orig['zeros'])\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\n# Pole-Zero Plot for the reduced circuit\n#| label: fig-pole-zero-plot-reduced\n#| fig-cap: Pole-Zero plot: Reduced circuit\n\nplot_poles_and_zeros(poles=solution_redux['poles'],\n                     zeros=solution_redux['zeros'])\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "KLayout-PEX",
    "section": "Install",
    "text": "Install\npip install klayout-pex\nAfter that, you should be able to run kpex --help."
  },
  {
    "objectID": "index.html#status",
    "href": "index.html#status",
    "title": "KLayout-PEX",
    "section": "Status",
    "text": "Status\n\n\n\n\n\n\nWarning\n\n\n\nPlease keep in mind that this software is early stage, and not yet intended for production use.\n\n\n\n\n\n\n\n\n\n\n\nEngine\nPEX Type\nStatus\nDescription\n\n\n\n\nKPEX/MAGIC\nCC, RC\nUsable\nWrapper engine, using installed magic tool\n\n\nKPEX/FasterCap\nCC\nUsable, pending QA\nField solver engine using FasterCap\n\n\nKPEX/FastHenry2\nR, L\nPlanned\nField solver engine using FastHenry2\n\n\nKPEX/2.5D\nCC\nUnder construction\nPrototype engine implementing MAGIC concepts/formulas with KLayout means\n\n\nKPEX/2.5D\nR, RC\nPlanned\nPrototype engine implementing MAGIC concepts/formulas with KLayout means"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "KLayout-PEX",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nSpecial thanks to the public funded German project FMD-QNC (16ME0831) https://www.elektronikforschung.de/projekte/fmd-qnc for financial support to this work."
  },
  {
    "objectID": "doc/test-reports.html",
    "href": "doc/test-reports.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "&lt;/div&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"&gt;About&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2luZGV4Lmh0bWw=\"&gt;/index.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6RG9jdW1lbnRhdGlvbg==\"&gt;Documentation&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9kb2MuaHRtbA==\"&gt;/doc/doc.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6UERG\"&gt;PDF&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9kb2MucGRm\"&gt;/doc/doc.pdf&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI68J+apiBUZXN0IFJlcG9ydHM=\"&gt;🚦 Test Reports&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy90ZXN0LXJlcG9ydHMuaHRtbA==\"&gt;/doc/test-reports.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI68J+QjSBDb3ZlcmFnZQ==\"&gt;🐍 Coverage&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9weXRob24tY292ZXJhZ2UuaHRtbA==\"&gt;/doc/python-coverage.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IG1ldGEgdmFyLnVybC1yZXBvID59fQ==\"&gt;https://github.com/martinjankoehler/klayout-pex-website&lt;/span&gt;&lt;/p&gt;\n&lt;div class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"Zm9vdGVyLXJpZ2h0\"&gt;\n&lt;p&gt;Website built with &lt;a href=\"https://quarto.org/\" class=\"external\" target=\"_blank\"&gt;Quarto&lt;/a&gt; &lt;br&gt; &lt;a href=\"https://github.com/martinjankoehler/klayout-pex-website\" class=\"external\" target=\"_blank\"&gt;Code source&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\n  window.document.addEventListener(\"DOMContentLoaded\", function (event) {\n    // Ensure there is a toggle, if there isn't float one in the top right\n    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {\n      const a = window.document.createElement('a');\n      a.classList.add('top-right');\n      a.classList.add('quarto-color-scheme-toggle');\n      a.href = \"\";\n      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };\n      const i = window.document.createElement(\"i\");\n      i.classList.add('bi');\n      a.appendChild(i);\n      window.document.body.appendChild(a);\n    }\n    setColorSchemeToggle(hasAlternateSentinel())\n    const icon = \"\";\n    const anchorJS = new window.AnchorJS();\n    anchorJS.options = {\n      placement: 'right',\n      icon: icon\n    };\n    anchorJS.add('.anchored');\n    const isCodeAnnotation = (el) =&gt; {\n      for (const clz of el.classList) {\n        if (clz.startsWith('code-annotation-')) {                     \n          return true;\n        }\n      }\n      return false;\n    }\n    const onCopySuccess = function(e) {\n      // button target\n      const button = e.trigger;\n      // don't keep focus\n      button.blur();\n      // flash \"checked\"\n      button.classList.add('code-copy-button-checked');\n      var currentTitle = button.getAttribute(\"title\");\n      button.setAttribute(\"title\", \"Copied!\");\n      let tooltip;\n      if (window.bootstrap) {\n        button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n        button.setAttribute(\"data-bs-placement\", \"left\");\n        button.setAttribute(\"data-bs-title\", \"Copied!\");\n        tooltip = new bootstrap.Tooltip(button, \n          { trigger: \"manual\", \n            customClass: \"code-copy-button-tooltip\",\n            offset: [0, -8]});\n        tooltip.show();    \n      }\n      setTimeout(function() {\n        if (tooltip) {\n          tooltip.hide();\n          button.removeAttribute(\"data-bs-title\");\n          button.removeAttribute(\"data-bs-toggle\");\n          button.removeAttribute(\"data-bs-placement\");\n        }\n        button.setAttribute(\"title\", currentTitle);\n        button.classList.remove('code-copy-button-checked');\n      }, 1000);\n      // clear code selection\n      e.clearSelection();\n    }\n    const getTextToCopy = function(trigger) {\n        const codeEl = trigger.previousElementSibling.cloneNode(true);\n        for (const childEl of codeEl.children) {\n          if (isCodeAnnotation(childEl)) {\n            childEl.remove();\n          }\n        }\n        return codeEl.innerText;\n    }\n    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {\n      text: getTextToCopy\n    });\n    clipboard.on('success', onCopySuccess);\n    if (window.document.getElementById('quarto-embedded-source-code-modal')) {\n      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {\n        text: getTextToCopy,\n        container: window.document.getElementById('quarto-embedded-source-code-modal')\n      });\n      clipboardModal.on('success', onCopySuccess);\n    }\n      var localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\n      var mailtoRegex = new RegExp(/^mailto:/);\n        var filterRegex = new RegExp(\"https:\\/\\/martinjankoehler\\.github\\.io\\/klayout-pex-website\\/\");\n      var isInternal = (href) =&gt; {\n          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n      }\n      // Inspect non-navigation links and adorn them if external\n     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\n      for (var i=0; i&lt;links.length; i++) {\n        const link = links[i];\n        if (!isInternal(link.href)) {\n          // undo the damage that might have been done by quarto-nav.js in the case of\n          // links that we want to consider external\n          if (link.dataset.originalHref !== undefined) {\n            link.href = link.dataset.originalHref;\n          }\n        }\n      }\n    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n      const config = {\n        allowHTML: true,\n        maxWidth: 500,\n        delay: 100,\n        arrow: false,\n        appendTo: function(el) {\n            return el.parentElement;\n        },\n        interactive: true,\n        interactiveBorder: 10,\n        theme: 'quarto',\n        placement: 'bottom-start',\n      };\n      if (contentFn) {\n        config.content = contentFn;\n      }\n      if (onTriggerFn) {\n        config.onTrigger = onTriggerFn;\n      }\n      if (onUntriggerFn) {\n        config.onUntrigger = onUntriggerFn;\n      }\n      window.tippy(el, config); \n    }\n    const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n    for (var i=0; i&lt;noterefs.length; i++) {\n      const ref = noterefs[i];\n      tippyHover(ref, function() {\n        // use id or data attribute instead here\n        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n        try { href = new URL(href).hash; } catch {}\n        const id = href.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note) {\n          return note.innerHTML;\n        } else {\n          return \"\";\n        }\n      });\n    }\n    const xrefs = window.document.querySelectorAll('a.quarto-xref');\n    const processXRef = (id, note) =&gt; {\n      // Strip column container classes\n      const stripColumnClz = (el) =&gt; {\n        el.classList.remove(\"page-full\", \"page-columns\");\n        if (el.children) {\n          for (const child of el.children) {\n            stripColumnClz(child);\n          }\n        }\n      }\n      stripColumnClz(note)\n      if (id === null || id.startsWith('sec-')) {\n        // Special case sections, only their first couple elements\n        const container = document.createElement(\"div\");\n        if (note.children && note.children.length &gt; 2) {\n          container.appendChild(note.children[0].cloneNode(true));\n          for (let i = 1; i &lt; note.children.length; i++) {\n            const child = note.children[i];\n            if (child.tagName === \"P\" && child.innerText === \"\") {\n              continue;\n            } else {\n              container.appendChild(child.cloneNode(true));\n              break;\n            }\n          }\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(container);\n          }\n          return container.innerHTML\n        } else {\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(note);\n          }\n          return note.innerHTML;\n        }\n      } else {\n        // Remove any anchor links if they are present\n        const anchorLink = note.querySelector('a.anchorjs-link');\n        if (anchorLink) {\n          anchorLink.remove();\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        if (note.classList.contains(\"callout\")) {\n          return note.outerHTML;\n        } else {\n          return note.innerHTML;\n        }\n      }\n    }\n    for (var i=0; i&lt;xrefs.length; i++) {\n      const xref = xrefs[i];\n      tippyHover(xref, undefined, function(instance) {\n        instance.disable();\n        let url = xref.getAttribute('href');\n        let hash = undefined; \n        if (url.startsWith('#')) {\n          hash = url;\n        } else {\n          try { hash = new URL(url).hash; } catch {}\n        }\n        if (hash) {\n          const id = hash.replace(/^#\\/?/, \"\");\n          const note = window.document.getElementById(id);\n          if (note !== null) {\n            try {\n              const html = processXRef(id, note.cloneNode(true));\n              instance.setContent(html);\n            } finally {\n              instance.enable();\n              instance.show();\n            }\n          } else {\n            // See if we can fetch this\n            fetch(url.split('#')[0])\n            .then(res =&gt; res.text())\n            .then(html =&gt; {\n              const parser = new DOMParser();\n              const htmlDoc = parser.parseFromString(html, \"text/html\");\n              const note = htmlDoc.getElementById(id);\n              if (note !== null) {\n                const html = processXRef(id, note);\n                instance.setContent(html);\n              } \n            }).finally(() =&gt; {\n              instance.enable();\n              instance.show();\n            });\n          }\n        } else {\n          // See if we can fetch a full url (with no hash to target)\n          // This is a special case and we should probably do some content thinning / targeting\n          fetch(url)\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.querySelector('main.content');\n            if (note !== null) {\n              // This should only happen for chapter cross references\n              // (since there is no id in the URL)\n              // remove the first header\n              if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n                note.children[0].remove();\n              }\n              const html = processXRef(null, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      }, function(instance) {\n      });\n    }\n        let selectedAnnoteEl;\n        const selectorForAnnotation = ( cell, annotation) =&gt; {\n          let cellAttr = 'data-code-cell=\"' + cell + '\"';\n          let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n          return selector;\n        }\n        const selectCodeLines = (annoteEl) =&gt; {\n          const doc = window.document;\n          const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n          const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n          const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n          const lineIds = lines.map((line) =&gt; {\n            return targetCell + \"-\" + line;\n          })\n          let top = null;\n          let height = null;\n          let parent = null;\n          if (lineIds.length &gt; 0) {\n              //compute the position of the single el (top and bottom and make a div)\n              const el = window.document.getElementById(lineIds[0]);\n              top = el.offsetTop;\n              height = el.offsetHeight;\n              parent = el.parentElement.parentElement;\n            if (lineIds.length &gt; 1) {\n              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n              const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n              height = bottom - top;\n            }\n            if (top !== null && height !== null && parent !== null) {\n              // cook up a div (if necessary) and position it \n              let div = window.document.getElementById(\"code-annotation-line-highlight\");\n              if (div === null) {\n                div = window.document.createElement(\"div\");\n                div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n                div.style.position = 'absolute';\n                parent.appendChild(div);\n              }\n              div.style.top = top - 2 + \"px\";\n              div.style.height = height + 4 + \"px\";\n              div.style.left = 0;\n              let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n              if (gutterDiv === null) {\n                gutterDiv = window.document.createElement(\"div\");\n                gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n                gutterDiv.style.position = 'absolute';\n                const codeCell = window.document.getElementById(targetCell);\n                const gutter = codeCell.querySelector('.code-annotation-gutter');\n                gutter.appendChild(gutterDiv);\n              }\n              gutterDiv.style.top = top - 2 + \"px\";\n              gutterDiv.style.height = height + 4 + \"px\";\n            }\n            selectedAnnoteEl = annoteEl;\n          }\n        };\n        const unselectCodeLines = () =&gt; {\n          const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n          elementsIds.forEach((elId) =&gt; {\n            const div = window.document.getElementById(elId);\n            if (div) {\n              div.remove();\n            }\n          });\n          selectedAnnoteEl = undefined;\n        };\n          // Handle positioning of the toggle\n      window.addEventListener(\n        \"resize\",\n        throttle(() =&gt; {\n          elRect = undefined;\n          if (selectedAnnoteEl) {\n            selectCodeLines(selectedAnnoteEl);\n          }\n        }, 10)\n      );\n      function throttle(fn, ms) {\n      let throttle = false;\n      let timer;\n        return (...args) =&gt; {\n          if(!throttle) { // first call gets through\n              fn.apply(this, args);\n              throttle = true;\n          } else { // all the others get throttled\n              if(timer) clearTimeout(timer); // cancel #2\n              timer = setTimeout(() =&gt; {\n                fn.apply(this, args);\n                timer = throttle = false;\n              }, ms);\n          }\n        };\n      }\n        // Attach click handler to the DT\n        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n        for (const annoteDlNode of annoteDls) {\n          annoteDlNode.addEventListener('click', (event) =&gt; {\n            const clickedEl = event.target;\n            if (clickedEl !== selectedAnnoteEl) {\n              unselectCodeLines();\n              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n              if (activeEl) {\n                activeEl.classList.remove('code-annotation-active');\n              }\n              selectCodeLines(clickedEl);\n              clickedEl.classList.add('code-annotation-active');\n            } else {\n              // Unselect the line\n              unselectCodeLines();\n              clickedEl.classList.remove('code-annotation-active');\n            }\n          });\n        }\n    const findCites = (el) =&gt; {\n      const parentEl = el.parentElement;\n      if (parentEl) {\n        const cites = parentEl.dataset.cites;\n        if (cites) {\n          return {\n            el,\n            cites: cites.split(' ')\n          };\n        } else {\n          return findCites(el.parentElement)\n        }\n      } else {\n        return undefined;\n      }\n    };\n    var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n    for (var i=0; i&lt;bibliorefs.length; i++) {\n      const ref = bibliorefs[i];\n      const citeInfo = findCites(ref);\n      if (citeInfo) {\n        tippyHover(citeInfo.el, function() {\n          var popup = window.document.createElement('div');\n          citeInfo.cites.forEach(function(cite) {\n            var citeDiv = window.document.createElement('div');\n            citeDiv.classList.add('hanging-indent');\n            citeDiv.classList.add('csl-entry');\n            var biblioDiv = window.document.getElementById('ref-' + cite);\n            if (biblioDiv) {\n              citeDiv.innerHTML = biblioDiv.innerHTML;\n            }\n            popup.appendChild(citeDiv);\n          });\n          return popup.innerHTML;\n        });\n      }\n    }\n  });\n  &lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"nav-footer\"&gt;\n    &lt;div class=\"nav-footer-left\"&gt;\n      &nbsp;\n    &lt;/div&gt;   \n    &lt;div class=\"nav-footer-center\"&gt;\n      &nbsp;\n    &lt;/div&gt;\n    &lt;div class=\"nav-footer-right\"&gt;\n      &lt;div class='footer-contents'&gt;Website built with [Quarto](https://quarto.org/){.external target=\"_blank\"} &lt;br&gt;\n[Code source](https://github.com/martinjankoehler/klayout-pex-website){.external target=\"_blank\"}\n&lt;/div&gt;  \n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "doc/doc.html",
    "href": "doc/doc.html",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "In Electronic Design and Automation (EDA) for Integrated Circuits (ICs), a schematic presents an abstraction in comparison to the layout that will eventually be taped-out and fabricated by the semiconductor foundry.\nWhile in the schematic, a connection between device terminals is seen as an equipotential, the stacked geometries in a specific layout introduce parasitic effects, which can be thought of additional resistors, capacitors (and inductors), not modeled by and missing in the original schematic.\nTo be able to simulate these effects, a parasitic extraction tool (PEX) is used, to extract a netlist from the layout, which represents the original schematic (created from the layout active and passive elements) augmented with the additional parasitic devices.\n\n\n\nSpecial thanks to the public funded German project FMD-QNC (16ME0831) https://www.elektronikforschung.de/projekte/fmd-qnc for financial support to this work.\n\n\n\nKLayout is an open source VLSI layout viewer and editor.\nKLayout-PEX (short KPEX) is a PEX tool, well integrated with KLayout by using its API.\nThere are multiple PEX engines supported, currently:\n\nFasterCap integration (field solver engine)\nMAGIC integration (wrapper calling magic)\nAnalytical 2.5D engine (parasitic concepts and formulas of MAGIC, implemented using KLayout methods)\n\n\n\n\n\n\n\nTip\n\n\n\nKPEX tool source code itself is made publicly available on GitHub (follow this link) and shared under the GPL-3.0 license.\nKPEX documentation source code is made publicly available on GitHub (follow this link) and shared under the Apache-2.0 license.\nPlease feel free to create issues and/or submit pull requests on GitHub to fix errors and omissions!\nThe production of the tool and this document would be impossible without these (and many more) great open-source software products: KLayout, FasterCap, MAGIC, protobuf, Quarto, Python, ngspice, Numpy, Scipy, Matplotlib, Git, Docker, Ubuntu, Linux…\n\n\n\n\n\n\n\n\nCaution\n\n\n\nCurrently, KPEX is developed as a Python prototype, using the KLayout Python API. This allows for a faster development cycle during the current prototyping phase.\nEventually, critical parts will be re-implemented (in C++, and parallelized), to improve performance. As we’re already using the KLayout API (which is pretty similar between Python, Ruby and C++), this will be relatively straight-forward.\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPlease keep in mind that this software is early stage, and not yet intended for production use.\n\n\n\n\n\n\n\n\n\n\n\nEngine\nPEX Type\nStatus\nDescription\n\n\n\n\nKPEX/MAGIC\nCC, RC\nUsable\nWrapper engine, using installed magic tool\n\n\nKPEX/FasterCap\nCC\nUsable, pending QA\nField solver engine using FasterCap\n\n\nKPEX/FastHenry2\nR, L\nPlanned\nField solver engine using FastHenry2\n\n\nKPEX/2.5D\nCC\nUnder construction\nPrototype engine implementing MAGIC concepts/formulas with KLayout means\n\n\nKPEX/2.5D\nR, RC\nPlanned\nPrototype engine implementing MAGIC concepts/formulas with KLayout means\n\n\n\n\n\n\nGenerally, KPEX is deployed using PyPi (Python Package Index), install via:\npip3 install --upgrade klayout-pex\n\nkpex --version   # check the installed version \nkpex --help      # this will help with command line arguments\nAs for the dependencies, there are multiple options available.\n\n\nWe provide a comprehensive, low entry barrier Docker image that comes pre-installed with most relevant open source ASIC tools, as well as the open PDKs. This is a pre-compiled Docker image which allows to do circuit design on a virtual machine on virtually any type of computing equipment (personal PC, Raspberry Pi, cloud server) on various operating systems (Windows, macOS, Linux).\nFor further information please look at the Docker Hub page and for detailed instructions at the IIC-OSIC-TOOLS GitHub page.\n\n\n\n\n\n\nLinux\n\n\n\nIn this document, we assume that users have a basic knowledge of Linux and how to operate it using the terminal (shell). If you are not yet familiar with Linux (which is basically a must when doing integrated circuit design as many tools are only available on Linux), then please check out a Linux introductory course or tutorial online, there are many resources available.\nA summary of important Linux shell commands is provided in IIC-JKU Linux Cheatsheet.\n\n\n\n\n\n\nKLayout layout tool:\n\nis mandatory for all engines (besides the MAGIC-wrapper)\nget the latest pre-built package version\nor follow the build instructions\n\nFasterCap engine:\n\noptional, required to run the FasterCap engine\neither compile your own version from the GitHub repository\nor use precompiled versions available at https://github.com/martinjankoehler/FasterCap/releases\n\nMAGIC-wrapper engine:\n\noptional, required to run the MAGIC-wrapper engine\nFollow the installation instructions at the GitHub repository\n\nSkywater sky130A PDK:\n\noptional, for now, KPEX technology specific files are deployed within the klayout-pex Python package\npip3 install --upgrade volare (install PDK package manager)\nvolare ls-remote (retrieve available PDK releases\n\nfor example PRE-RELEASE 0c1df35fd535299ea1ef74d1e9e15dedaeb34c32 (2024.12.11))\n\nvolare enable 0c1df35fd535299ea1ef74d1e9e15dedaeb34c32 (install a PDK version)\nPDK files now have been installed under $HOME/.volare/sky130A\n\nIHP SG13G2 PDK:\n\noptional, for now, KPEX technology specific files are deployed within the klayout-pex Python package\ngit clone https://github.com/IHP-GmbH/IHP-Open-PDK (install PDK package manager)\n\n\n\n\n\nFor previewing generated 3D geometries, representing the input to FasterCap, we recommend installing MeshLab. The generated STL-files are located at output/&lt;design&gt;/Geometries/*.stl.\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#motivation",
    "href": "doc/doc.html#motivation",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "In Electronic Design and Automation (EDA) for Integrated Circuits (ICs), a schematic presents an abstraction in comparison to the layout that will eventually be taped-out and fabricated by the semiconductor foundry.\nWhile in the schematic, a connection between device terminals is seen as an equipotential, the stacked geometries in a specific layout introduce parasitic effects, which can be thought of additional resistors, capacitors (and inductors), not modeled by and missing in the original schematic.\nTo be able to simulate these effects, a parasitic extraction tool (PEX) is used, to extract a netlist from the layout, which represents the original schematic (created from the layout active and passive elements) augmented with the additional parasitic devices."
  },
  {
    "objectID": "doc/doc.html#acknowledgements",
    "href": "doc/doc.html#acknowledgements",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "Special thanks to the public funded German project FMD-QNC (16ME0831) https://www.elektronikforschung.de/projekte/fmd-qnc for financial support to this work."
  },
  {
    "objectID": "doc/doc.html#about-klayout-pex",
    "href": "doc/doc.html#about-klayout-pex",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "KLayout is an open source VLSI layout viewer and editor.\nKLayout-PEX (short KPEX) is a PEX tool, well integrated with KLayout by using its API.\nThere are multiple PEX engines supported, currently:\n\nFasterCap integration (field solver engine)\nMAGIC integration (wrapper calling magic)\nAnalytical 2.5D engine (parasitic concepts and formulas of MAGIC, implemented using KLayout methods)\n\n\n\n\n\n\n\nTip\n\n\n\nKPEX tool source code itself is made publicly available on GitHub (follow this link) and shared under the GPL-3.0 license.\nKPEX documentation source code is made publicly available on GitHub (follow this link) and shared under the Apache-2.0 license.\nPlease feel free to create issues and/or submit pull requests on GitHub to fix errors and omissions!\nThe production of the tool and this document would be impossible without these (and many more) great open-source software products: KLayout, FasterCap, MAGIC, protobuf, Quarto, Python, ngspice, Numpy, Scipy, Matplotlib, Git, Docker, Ubuntu, Linux…\n\n\n\n\n\n\n\n\nCaution\n\n\n\nCurrently, KPEX is developed as a Python prototype, using the KLayout Python API. This allows for a faster development cycle during the current prototyping phase.\nEventually, critical parts will be re-implemented (in C++, and parallelized), to improve performance. As we’re already using the KLayout API (which is pretty similar between Python, Ruby and C++), this will be relatively straight-forward."
  },
  {
    "objectID": "doc/doc.html#status",
    "href": "doc/doc.html#status",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "Warning\n\n\n\nPlease keep in mind that this software is early stage, and not yet intended for production use.\n\n\n\n\n\n\n\n\n\n\n\nEngine\nPEX Type\nStatus\nDescription\n\n\n\n\nKPEX/MAGIC\nCC, RC\nUsable\nWrapper engine, using installed magic tool\n\n\nKPEX/FasterCap\nCC\nUsable, pending QA\nField solver engine using FasterCap\n\n\nKPEX/FastHenry2\nR, L\nPlanned\nField solver engine using FastHenry2\n\n\nKPEX/2.5D\nCC\nUnder construction\nPrototype engine implementing MAGIC concepts/formulas with KLayout means\n\n\nKPEX/2.5D\nR, RC\nPlanned\nPrototype engine implementing MAGIC concepts/formulas with KLayout means"
  },
  {
    "objectID": "doc/doc.html#sec-intro-installation",
    "href": "doc/doc.html#sec-intro-installation",
    "title": "KLayout-PEX Documentation",
    "section": "",
    "text": "Generally, KPEX is deployed using PyPi (Python Package Index), install via:\npip3 install --upgrade klayout-pex\n\nkpex --version   # check the installed version \nkpex --help      # this will help with command line arguments\nAs for the dependencies, there are multiple options available.\n\n\nWe provide a comprehensive, low entry barrier Docker image that comes pre-installed with most relevant open source ASIC tools, as well as the open PDKs. This is a pre-compiled Docker image which allows to do circuit design on a virtual machine on virtually any type of computing equipment (personal PC, Raspberry Pi, cloud server) on various operating systems (Windows, macOS, Linux).\nFor further information please look at the Docker Hub page and for detailed instructions at the IIC-OSIC-TOOLS GitHub page.\n\n\n\n\n\n\nLinux\n\n\n\nIn this document, we assume that users have a basic knowledge of Linux and how to operate it using the terminal (shell). If you are not yet familiar with Linux (which is basically a must when doing integrated circuit design as many tools are only available on Linux), then please check out a Linux introductory course or tutorial online, there are many resources available.\nA summary of important Linux shell commands is provided in IIC-JKU Linux Cheatsheet.\n\n\n\n\n\n\nKLayout layout tool:\n\nis mandatory for all engines (besides the MAGIC-wrapper)\nget the latest pre-built package version\nor follow the build instructions\n\nFasterCap engine:\n\noptional, required to run the FasterCap engine\neither compile your own version from the GitHub repository\nor use precompiled versions available at https://github.com/martinjankoehler/FasterCap/releases\n\nMAGIC-wrapper engine:\n\noptional, required to run the MAGIC-wrapper engine\nFollow the installation instructions at the GitHub repository\n\nSkywater sky130A PDK:\n\noptional, for now, KPEX technology specific files are deployed within the klayout-pex Python package\npip3 install --upgrade volare (install PDK package manager)\nvolare ls-remote (retrieve available PDK releases\n\nfor example PRE-RELEASE 0c1df35fd535299ea1ef74d1e9e15dedaeb34c32 (2024.12.11))\n\nvolare enable 0c1df35fd535299ea1ef74d1e9e15dedaeb34c32 (install a PDK version)\nPDK files now have been installed under $HOME/.volare/sky130A\n\nIHP SG13G2 PDK:\n\noptional, for now, KPEX technology specific files are deployed within the klayout-pex Python package\ngit clone https://github.com/IHP-GmbH/IHP-Open-PDK (install PDK package manager)\n\n\n\n\n\nFor previewing generated 3D geometries, representing the input to FasterCap, we recommend installing MeshLab. The generated STL-files are located at output/&lt;design&gt;/Geometries/*.stl.\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#example-layouts",
    "href": "doc/doc.html#example-layouts",
    "title": "KLayout-PEX Documentation",
    "section": "2.1 Example Layouts",
    "text": "2.1 Example Layouts\nExample layouts are included in the testdata/designs subdirectory of the KLayout-PEX source code:\ngit clone https://github.com/martinjankoehler/klayout-pex.git \n\n# for sky130A\nfind testdata/designs/sky130A -name \"*.gds.gz\"\n\n# for IHP SG13G2\nfind testdata/designs/ihp_sg13g2 -name \"*.gds.gz\""
  },
  {
    "objectID": "doc/doc.html#sec-first-steps-run-fastercap-engine",
    "href": "doc/doc.html#sec-first-steps-run-fastercap-engine",
    "title": "KLayout-PEX Documentation",
    "section": "2.2 Running the KPEX/FasterCap engine",
    "text": "2.2 Running the KPEX/FasterCap engine\nPreconditions:\n\nklayout-pex was installed, see Section 1.5\nFasterCap was installed, see Section 1.5\n\n\n\n\n\n\n\nNote\n\n\n\nNormally, devices with SPICE (Nagel 1975) simulation models (e.g. like MOM-capacitors1 in the sky130A PDK) are ignored (“blackboxed”) during parasitic extraction.\nkpex has an option --blacklist n to allow extraction of those devices (whiteboxing), which can be useful during development (during the prototype phase, whiteboxing is actually the default setting, so please use --blacklist y to explicitly configure blackboxing).\n\n\nLet’s try the following:\nkpex --pdk sky130A --blackbox n --gds \\\n  testdata/designs/sky130A/*/cap_vpp_04p4x04p6_l1m1m2_noshield.gds.gz\n\n\n\n\n\n\nNote\n\n\n\nThis will report an error that we have not activated one or more engines, and list the available engines:\n\n\n\nArgument\nDescription\n\n\n\n\n--fastercap\nRun kpex/FasterCap engine\n\n\n--2.5D\nRun kpex/2.5D engine\n\n\n--magic\nRun MAGIC engine\n\n\n\n\n\nNow, to run the FasterCap engine (might take a couple of minutes):\nkpex --pdk sky130A --blackbox n --fastercap --gds \\\n  testdata/designs/sky130A/*/cap_vpp_04p4x04p6_l1m1m2_noshield.gds.gz\nWithin the output directory (defaults to output), KPEX creates a subdirectory Geometries, containing STL-files that provide a preview of the FasterCap input geometries. Use MeshLab (see Section 1.5.3) to open and preview those files:\nls -d output/cap_vpp_04*/Geometries/*.stl\n\n\n\n\n\n\nTip\n\n\n\n\nOpen the *.stl files in MeshLab\nUse the eye buttons to hide and show each file/mesh\nUse the align tool (“A” in the toolbar) to assign different colors\nStart by showing only on the conductors (files named cond_*.stl)\nThen try showing different dielectrics (files named diel_*.stl), to see how they surround the conductors.\n\n\n\n\nIn the log file, we see the output of FasterCap including the Maxwell capacitance matrix:\nCapacitance matrix is:\nDimension 3 x 3\ng1_VSUBS  5.2959e-09 -4.46971e-10 -1.67304e-09\ng2_C1  -5.56106e-10 1.5383e-08 -1.47213e-08\ng3_C0  -1.69838e-09 -1.48846e-08 1.64502e-08\nKPEX interprets this matrix and prints a CSV netlist, which can be pasted into a spreadsheet application:\nDevice;Net1;Net2;Capacitance [fF]\nCext_0_1;VSUBS;C1;0.5\nCext_0_2;VSUBS;C0;1.69\nCext_1_2;C1;C0;14.8\nCext_1_1;C1;VSUBS;0.08\nIn addition, a SPICE netlist is generated."
  },
  {
    "objectID": "doc/doc.html#sec-first-steps-run-magic-engine",
    "href": "doc/doc.html#sec-first-steps-run-magic-engine",
    "title": "KLayout-PEX Documentation",
    "section": "2.3 Running the KPEX/MAGIC engine",
    "text": "2.3 Running the KPEX/MAGIC engine\nPreconditions:\n\nklayout-pex was installed, see Section 1.5\nmagic was installed, see Section 1.5\n\nThe magic section of kpex --help describes the arguments and their defaults. Important arguments:\n\n--magicrc: specify location of the magicrc file\n--gds: path to the GDS input layout\n--magic: enable magic engine\n\nkpex --pdk sky130A --magic --gds \\\n  testdata/designs/sky130A/*/cap_vpp_04p4x04p6_l1m1m2_noshield.gds.gz\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#sec-tech-def",
    "href": "doc/doc.html#sec-tech-def",
    "title": "KLayout-PEX Documentation",
    "section": "3.1 Technology Definition Files",
    "text": "3.1 Technology Definition Files\nThe KPEX technology definition format uses Google Protocol Buffers, so there is:\n\nformal schema files, defining the structure and data types involved\n\nprotos/tech.proto: main schema / entry point, includes the others\nprotos/process_stack.proto: describes details of the process stack, such as dielectrics and heights of layers\nprotos/process_parasitics.proto: parasitic tables, used to parametrize the 2.5D engine\n\nmultiple concrete instantiations, that adhere to this schema (called messages in the protobuf lingo)\n\nin the form of JSON files\nSkywater 130A: klayout_pex_protobuf/sky130A_tech.pb.json\nIHP SG13G2: klayout_pex_protobuf/ihp_sg13g2_tech.pb.json\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe built-in JSON tech files are programmatically generated during the build process2. Therefore they not part of the repository source code, but of course part of the deployed Python wheels. To review those, look into your Python site-packages3/klayout_pex_protobuf."
  },
  {
    "objectID": "doc/doc.html#customized-pex-lvs-scripts",
    "href": "doc/doc.html#customized-pex-lvs-scripts",
    "title": "KLayout-PEX Documentation",
    "section": "3.2 Customized PEX-“LVS” scripts",
    "text": "3.2 Customized PEX-“LVS” scripts\nKLayout has built-in support for Layout-Versus-Schematic (LVS) scripts, based on its Ruby API. Customized “LVS” scripts are (“ab”)used in KPEX, not with the intent of comparing Layout-Versus-Schematic, but rather to extract the connectivity/net information for all polygons across multiple layers. The resulting net information is stored in a KLayout LVS Database (“LVSDB”).\n\n\n\nKPEX Net Formation\n\n\nThese customized “LVS” scripts are stored in:\n\nSkywater sky130A: pdk/sky130A/libs.tech/kpex/sky130.lvs\nIHP SG13G2: pdk/ihp_sg13gs/libs.tech/kpex/sg13g2.lvs\n\nWhat’s specific about this customization:\n\nLayers names must be assigned, using KLayout’s (name(layer, name)) function\nMOM4 capacitors, MIM5 capacitors and resistors should be extracted to separate layers, to enable blackboxing / whiteboxing.\n\nThe layer names in the script must correspond with the names configured in the tech JSON file.\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#d-input-geometries",
    "href": "doc/doc.html#d-input-geometries",
    "title": "KLayout-PEX Documentation",
    "section": "4.1 3D Input Geometries",
    "text": "4.1 3D Input Geometries\n\n\n\nFasterCap 3D Input: File System Overview\n\n\nThe FasterCap input files and their format is documented in (Di Lorenzo 2019), a PDF version of the Windows-specific *.chm file is available at https://github.com/martinjankoehler/FasterCap/tree/master/doc/pdf.\nKPEX generates 3D input geometries:\n\n*.lst file: Main input file\n\ndefines dielectric instances\ndefines conductor instances\neach instance refers to a *.geo file\n\n*.geo files: Defines single geometry\n\ndefines shapes (e.g. triangles)\nEach shape has a reference point to define inside/outsides\n\n\n\n\n\nFasterCap 3D Input: File Format"
  },
  {
    "objectID": "doc/doc.html#example-mom-capacitor",
    "href": "doc/doc.html#example-mom-capacitor",
    "title": "KLayout-PEX Documentation",
    "section": "4.2 Example: MOM Capacitor",
    "text": "4.2 Example: MOM Capacitor\n\n\n\n\n\n\n\n\nMOM Capacitor: GDS Layout\n\n\n\n\n\n\n\n\n\nMOM Capacitor: MeshLab 3D Preview\n\n\n\n\n\n\nFigure 1: MOM Capacitor\n\n\n\nFigure 1 depicts the MOM capacitor example of a from Section 2.2).\nThe corresponding schematic representation of Figure 2 contains 3 conductors (\\(N_1\\), \\(N_2\\) and \\(N_3\\)), and coupling capacitances:\n\nCapacitances between conductors: \\(C_{ij} \\text{ where } i \\ne j\\)\n\n\\(C_{23}\\) is the capacitance “intended” by the MOM designer\n\nCapacitances between conductors and ground: \\(C_{ii}\\)\n\n\n\n\n\n\n\n\n\nFigure 2: Schematic representation of the MOM capacitor."
  },
  {
    "objectID": "doc/doc.html#output-maxwell-capacitance-matrix",
    "href": "doc/doc.html#output-maxwell-capacitance-matrix",
    "title": "KLayout-PEX Documentation",
    "section": "4.3 Output Maxwell Capacitance Matrix",
    "text": "4.3 Output Maxwell Capacitance Matrix\nA Maxwell capacitance matrix (Maxwell 1873) provides the relation between voltages on a set of conductors and the charges on these conductors, as described by the FasterCap author in the white paper (Di Lorenzo 2023).\nFasterCap log output prints the Maxwell capacitance matrix (one for each iteration/refinement).\n\n\n\nFasterCap Log Output: Maxwell Capacitance Matrix\n\n\n\nMatrix Properties:\n\nScaling: units have to be divided by \\(10^{-6}\\)\nrows and columns are the same (list of net names)\nRow Cells:\n\noff diagonals cells contains the coupling between row/col nets (times \\(-1\\))\ndiagonal cells contains the sum of the absolute values of all other cells in the row\n\nMatrix Symmetry:\n\nin theory (ideal world), the matrix would be symmetric\nin practice it’s not\n\ntherefore FastCap2 did average the off-diagonals\nFasterCap does not average, so it’s done as part of KPEX\n\n\n\n\n\n\nFasterCap Maxwell Capacitance Matrix: Interpretation\n\n\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#magic-database-units",
    "href": "doc/doc.html#magic-database-units",
    "title": "KLayout-PEX Documentation",
    "section": "5.1 MAGIC database units",
    "text": "5.1 MAGIC database units\n\nTo convert between MAGIC database units and \\(\\mu m\\), a scaling factor \\(\\alpha\\) is used, so that \\(L_{\\mu m} = \\frac{L_{dbu}}{\\alpha}\\)\nE.g. for sky130A, \\(\\alpha = 200.0\\)"
  },
  {
    "objectID": "doc/doc.html#sec-magic-cap-types",
    "href": "doc/doc.html#sec-magic-cap-types",
    "title": "KLayout-PEX Documentation",
    "section": "5.2 Types of Parasitic Capacitances",
    "text": "5.2 Types of Parasitic Capacitances\nMAGIC models multiple types of capacitances:\n\nSubstrate Overlap: Overlap area of a metal with the substrate\nSubstrate Fringing: Sidewall of a metal fringes out to substrate\nSidewall Capacitance: Coupling between adjacent sidewalls on the same layer\nOverlap Capacitance: Overlap on different metal layers\nFringe Capacitance (“Side Overlap”): Sidewall of a metal fringes out other metal layers"
  },
  {
    "objectID": "doc/doc.html#substrate-capacitance",
    "href": "doc/doc.html#substrate-capacitance",
    "title": "KLayout-PEX Documentation",
    "section": "5.3 Substrate Capacitance",
    "text": "5.3 Substrate Capacitance\n\n\nOverlapping area: \\[\nC_{area} = \\frac{\\epsilon_{si} * K}{d} * \\text{area} \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{F}{\\mu m^2} * \\mu m^2\\right]\n\\]\nFringe (“Perimeter”): \\[\nC_{fringe\\,to\\,substrate} = \\text{perimeter} * C_{perim} = (2l + 2w)*C_{perim}\n\\]\nCoefficients like \\(C_{perim}\\) are part of the tech files (Parasitic Tables)"
  },
  {
    "objectID": "doc/doc.html#sidewall-capacitance",
    "href": "doc/doc.html#sidewall-capacitance",
    "title": "KLayout-PEX Documentation",
    "section": "5.4 Sidewall Capacitance",
    "text": "5.4 Sidewall Capacitance\n\n\\[\nC_{sidewall} = \\frac{\\epsilon_{si} * K}{s} * \\text{sidewall area}  \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{F}{\\mu m^2} * \\mu m^2\\right]\n\\] \\[\n\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,= \\frac{\\epsilon_{si} * K}{s} * t * l  \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{F}{\\mu m^2} * \\mu m * \\mu m\\right]\n\\] \\[\nC_{sidewall} = \\frac{C_{sidewall\\,coeff}}{s} * l \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{F}{\\mu m} * \\mu m\\right]\n\\]\n\n\nCoefficients are part of the tech files (Parasitic Tables)\nLayer thickness \\(t\\) is normally multiplied into the coefficient\nFoundry tables give constant coefficient referenced to \\(s = 1\\)"
  },
  {
    "objectID": "doc/doc.html#overlap-capacitance",
    "href": "doc/doc.html#overlap-capacitance",
    "title": "KLayout-PEX Documentation",
    "section": "5.5 Overlap Capacitance",
    "text": "5.5 Overlap Capacitance\n\nOverlapping area: \\[\nC_{area} = \\frac{\\epsilon_{si} * K}{d} * \\text{area} \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{F}{\\mu m^2} * \\mu m^2\\right]\n\\]\n\n\n\n\nOverlap Capacitance"
  },
  {
    "objectID": "doc/doc.html#fringe-capacitance",
    "href": "doc/doc.html#fringe-capacitance",
    "title": "KLayout-PEX Documentation",
    "section": "5.6 Fringe Capacitance",
    "text": "5.6 Fringe Capacitance\n\n\n\nFringe Capacitance: Overlapping (1)\n\n\n\nCausing sidewall (its bottom edge depicted red)\nAssume: Field is bounded by fringe halo (e.g. \\(8\\, \\mu m\\) away from edge)\nFractions of fringe goes to metal1 or substrate\n\n\n\n\nFringe Capacitance: Overlapping (2)\n\n\n\nMultiplier \\(\\alpha\\) (comes from tech files: overlap table)\n\ndetermines how quickly fringe capacitance drops with increasing distance\n\\(\\alpha\\) is related to distance \\(d\\)￼ between layers\n\\(\\alpha\\) is proportional to \\(C_{overlap_{metal1 \\leftrightarrow metal2}}= \\frac{\\epsilon_{si} * K}{d} * \\text{area}\\)\n(for fixed value of area \\(1\\, \\mu m^2\\)) \n\nFringe Fractions:\n\n\\(\\text{frac}_{metal1} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha_{metal2 \\rightarrow metal1}*x)\\)\n\\(\\text{frac}_{sub} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha_{metal2 \\rightarrow sub}*(\\text{halo}-x))\\)\n\\(\\tfrac{2}{\\pi}\\) is multiplied because of scaling to interval \\([0.0,\\,1.0]\\), as￼\\(\\text{atan}(\\infty)=\\tfrac{\\pi}{2}\\)\n\nOverlap capacitance:\n\n\\(C_{overlap} = \\frac{\\epsilon_{si} * K}{d} * \\text{area} \\,\\,\\,\\,\\,\\,\\,\\,(\\text{with area}=1 \\mu m^2)\\)\n\nCoupling capacitance \\(metal1 \\leftrightarrow metal2\\):\n\n\\(\\alpha_{metal1 \\leftrightarrow metal2} = \\alpha_{scalefac} * C_{overlap_{metal1 \\leftrightarrow metal2}}\\)\n\\(\\text{frac}_{metal1} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha_{metal1 \\leftrightarrow metal2}*x)\\)\n\\(\\text{effective length} = \\text{edge length} * \\text{frac}_{metal1}\\)\n\\(C_{fringe_{metal2 \\rightarrow metal1}} = \\text{effective length} * C_{sideoverlap_{metal2 \\rightarrow metal1}}\\)\n\nCoupling capacitance \\(metal1 \\leftrightarrow sub\\):\n\n\\(\\alpha_{metal1 \\leftrightarrow sub} = \\alpha_{scalefac} * C_{overlap_{metal1 \\leftrightarrow sub}}\\)\n\\(\\text{frac}_{sub} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha_{metal1 \\leftrightarrow sub}*(\\text{halo}-x))\\)\n\\(\\text{effective length} = \\text{edge length} * \\text{frac}_{sub}\\)\n\\(C_{fringe_{metal2 \\rightarrow sub}} = \\text{effective length} * C_{sideoverlap_{metal2 \\rightarrow sub}}\\)\n\n\n\n\n\nFringe Capacitance: Non Overlapping (1)\n\n\n\nPartial side overlap\n\nIn case there is only a partial side overlap, the non-existing near fraction is subtracted from the far fraction\n\\(metal1\\) wire is offset, starts at \\(x_{near}\\)\n\\(metal1\\) ends at \\(x_{far}\\)\n\n\n\n\n\nFringe Capacitance: Non Overlapping (2)\n\n\n\n\\(\\text{frac}_{near} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha*x_{near})\\)\n\\(\\text{frac}_{far} = \\tfrac{2}{\\pi} * \\text{atan}(\\alpha*x_{far})\\)\n\\(\\text{frac} = \\text{frac}_{far}-\\text{frac}_{near}\\)"
  },
  {
    "objectID": "doc/doc.html#shielding-effects",
    "href": "doc/doc.html#shielding-effects",
    "title": "KLayout-PEX Documentation",
    "section": "5.7 Shielding Effects",
    "text": "5.7 Shielding Effects\n\n\n\nTable 1: Shielding effects\n\n\n\n\n\n\n\n\n\n\n\nType\nShielding\n\n\n\nTo Substrate\nBetween layers\nOn same layer\n\n\n\n\nOverlap shielding\n✔\n✔\n✘\n\n\nSidewall shielding\n✘\n✘\n✔\n\n\nLateral fringe shielding\n✘\n✔\n✔\n\n\nVertical fringe shielding\n✔\n✔\n✘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverlap shielding\n\n\n\n\n\n\n\nSidewall shielding\n\n\n\n\n\n\n\n\n\nLateral fringe shielding (1/2)\n\n\n\n\n\n\n\nVertical fringe shielding\n\n\n\n\n\n\nFigure 3: Shielding Effects\n\n\n\nNote, given an analyzed sidewall (edge in 2D), lateral fringe shielding\n\nis caused by opposing shapes on the same layer\n\neven by the same polygon\nby other polygons (same net)\nby other polygons (different net) — this is what we also look at when analyzing sidewall coupling\n\nwill shield the fringing to the lower layers, i.e. in Figure 4 the coupling between the two shapes is the same in the above and below cases\n\n\n\n\n\n\n\nFigure 4: Lateral fringe shielding (2/2)"
  },
  {
    "objectID": "doc/doc.html#parasitic-resistance",
    "href": "doc/doc.html#parasitic-resistance",
    "title": "KLayout-PEX Documentation",
    "section": "5.8 Parasitic Resistance",
    "text": "5.8 Parasitic Resistance\nMagic constructs a graph of resistors between nodes\n\ndevice terminals\npins\njunctions\n\n\n5.8.1 Wire resistance\n\nGiven a wire with length \\(l\\) and height \\(h\\), the basic formula is \\[\nR_{wire} = \\frac{l}{h} * R_{coeff}  \\,\\,\\,\\,\\,\\,\\, \\left[ \\frac{\\mu m}{\\mu m} * mΩ\\right]\n\\]\nCoefficient \\(R_{coeff}\\) is part of the tech files (Parasitic Tables)\n\ndefined for every metal layer\nin \\(mΩ\\) for \\(1\\,{\\mu m}^2\\)\nCoefficient already includes the thickness aspect of the layer, so the formula works in 2D\n\n\n\n\n5.8.2 Via resistance\n\n\n\n\n\n\nFigure 5: Via dimensions)\n\n\n\n\nGiven\n\ndrawn via in the layout, with width \\(w\\) and height \\(h\\)\ndesign rules defined for each via layer:\n\nvia width \\(viawidth\\)\n\\(spacing\\) between vias (in case of a via array)\n\\(border\\) on each side of the via\n\n\nMAGIC interpretation of the via drawing\n\ndetermine number of vias in \\(x\\) and \\(y\\) direction, i.e. \\(n_x\\) and \\(n_y\\)\nif \\(x\\) and \\(y\\) dimensions are below the minimum size, MAGIC counts 1 via in each direction\nif the dimensions are larger, we calculate how much vias fit\n\n\n\\[\nR_{via} = \\frac{R_{coeff}}{n_x * n_y}   \\,\\,\\,\\,\\,\\,\\, \\left[\\frac{mΩ}{\\text{via count}}\\right]\n\\]\n\\[\nn_x = 1 + \\left\\lfloor\\frac{w - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\\[\nn_y = 1 + \\left\\lfloor\\frac{h - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\nCoefficient \\(R_{coeff}\\) is part of the tech files (Parasitic Tables)\n\ndefined for every via layer\nin \\(mΩ\\) per via\nCoefficient already includes the thickness aspect of the layer, so the formula works in 2D\n\n\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#test-pattern-single_plate_100um_x_100um_li1_over_substrate",
    "href": "doc/doc.html#test-pattern-single_plate_100um_x_100um_li1_over_substrate",
    "title": "KLayout-PEX Documentation",
    "section": "7.1 Test Pattern single_plate_100um_x_100um_li1_over_substrate",
    "text": "7.1 Test Pattern single_plate_100um_x_100um_li1_over_substrate\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/single_plate_100um_x_100um_li1_over_substrate.gds.gz\n\n\n\n\n\nOverlap capacitance li1 to substrate.\n\n\n\n\n\nExtracted Parasitic Overlap Capacitances\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nOverlap\nli1\nli1\nsubstrate\nVSUBS\n369.9\n369.9\n4\n\n\n\n\n\n\n\n\nPerimeter (fringe) capacitance li1 to substrate.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nFringe (top)\nli1\nli1\nsubstrate\nVSUBS\n4.07\n4.07\n5\n\n\nFringe (left)\nli1\nli1\nsubstrate\nVSUBS\n4.07\n4.07\n6\n\n\nFringe (right)\nli1\nli1\nsubstrate\nVSUBS\n4.07\n4.07\n7\n\n\nFringe (bottom)\nli1\nli1\nsubstrate\nVSUBS\n4.07\n4.07\n8\n\n\n\nMagic 8.3 revision 486 - Compiled on `date`.\n----------------------------------------------------\n\nCapDebug (extNodeAreaFunc/Area) layer li(90), net li_0_0#, area=400000000 (10000 µm^2) nreg_cap += 369.9 fF\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 373.97 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 378.04 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 382.11 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 386.18 fF)\nCapDebug (extSetResist): li_0_0# area=400000000 (10000 µm^2) perim=80000 (400 µm)\nCapDebug ---"
  },
  {
    "objectID": "doc/doc.html#test-pattern-sidewall_20um_length_distance_200nm_li1",
    "href": "doc/doc.html#test-pattern-sidewall_20um_length_distance_200nm_li1",
    "title": "KLayout-PEX Documentation",
    "section": "7.2 Test Pattern sidewall_20um_length_distance_200nm_li1",
    "text": "7.2 Test Pattern sidewall_20um_length_distance_200nm_li1\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/sidewall_20um_length_distance_200nm_li1.gds.gz\n\n\n\n\n\nOverlap capacitance of nets on li1.\n\n\n\n\n\nExtracted Parasitic Overlap Capacitances\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nOverlap\nli1\nA\nsubstrate\nVSUBS\n0.7398\n0.74\n4\n\n\nOverlap\nli1\nB\nsubstrate\nVSUBS\n0.7398\n0.74\n11\n\n\n\n\n\n\n\n\nSidewall capacitance between nets A and B on li1.\n\n\n\n\n\nExtracted Parasitic Sidewall Capacitances\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer\nNet1\nNet2\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nSidewall\nli1\nA\nB\n0.75\n0.75\n18\n\n\nSidewall\nli1\nB\nA\n0.75\n0.75\n21\n\n\n\n\n\n\n\n\nFringe capacitance between net A and substrate.\n\n\n\n\n\nExtracted Parasitic Fringe Capacitances between nets A, B on li1 and substrate\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nFringe (top)\nli1\nA\nsubstrate\nVSUBS\n0.814\n0.814\n5\n\n\nFringe (left)\nli1\nA\nsubstrate\nVSUBS\n0.0407\n0.041\n6\n\n\nFringe (bottom)\nli1\nA\nsubstrate\nVSUBS\n0.814\n0.076\n7\n\n\nFringe (bottom)\nli1\nA\nsubstrate\nVSUBS\n-0.7379\n—\n19\n\n\nFringe (right)\nli1\nA\nsubstrate\nVSUBS\n0.0407\n0.041\n8\n\n\nFringe (top)\nli1\nB\nsubstrate\nVSUBS\n0.814\n0.076\n12\n\n\nFringe (top)\nli1\nB\nsubstrate\nVSUBS\n-0.7379\n—\n22\n\n\nFringe (left)\nli1\nB\nsubstrate\nVSUBS\n0.0407\n0.041\n13\n\n\nFringe (bottom)\nli1\nB\nsubstrate\nVSUBS\n0.814\n0.814\n14\n\n\nFringe (right)\nli1\nB\nsubstrate\nVSUBS\n0.0407\n0.041\n15\n\n\n\nMagic 8.3 revision 486 - Compiled on `date`.\n----------------------------------------------------\n\nCapDebug (extNodeAreaFunc/Area) layer li(90), net li_0_240#, area=800000 (20 µm^2) nreg_cap += 0.7398 fF\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer li(90), net li_0_240#, length=4000 (20 µm), nreg_cap += 0.814 fF (now nreg_cap = 1.5538 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer li(90), net li_0_240#, length=200 (1 µm), nreg_cap += 0.0407 fF (now nreg_cap = 1.5945 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer li(90), net li_0_240#, length=4000 (20 µm), nreg_cap += 0.814 fF (now nreg_cap = 2.4085 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer li(90), net li_0_240#, length=200 (1 µm), nreg_cap += 0.0407 fF (now nreg_cap = 2.4492 fF)\nCapDebug (extSetResist): li_0_240# area=800000 (20 µm^2) perim=8400 (42 µm)\nCapDebug ---\nCapDebug (extNodeAreaFunc/Area) layer li(90), net li_0_0#, area=800000 (20 µm^2) nreg_cap += 0.7398 fF\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer li(90), net li_0_0#, length=4000 (20 µm), nreg_cap += 0.814 fF (now nreg_cap = 1.5538 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer li(90), net li_0_0#, length=200 (1 µm), nreg_cap += 0.0407 fF (now nreg_cap = 1.5945 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer li(90), net li_0_0#, length=4000 (20 µm), nreg_cap += 0.814 fF (now nreg_cap = 2.4085 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer li(90), net li_0_0#, length=200 (1 µm), nreg_cap += 0.0407 fF (now nreg_cap = 2.4492 fF)\nCapDebug (extSetResist): li_0_0# area=800000 (20 µm^2) perim=8400 (42 µm)\nCapDebug ---\nCapDebug (sidewall): A-B (layer li), overlap=4000 (20 µm), sep=40 (0.2 µm), e-&gt;ec_cap=12.75 (0.0255 fF), e-&gt;ec_offset=28 (0.14 µm), delta += 0.75 fF …  now is 0.75 fF\nCapDebug (obsolete_fringe (blocked)): A -= 0.737881 fF …    now A == 1.711319 fF\n    overlapMult=0.003699 (3.699 aF/µm^2) dnear=40 (0.2 µm), snear=0.0935129 (0.000467564 µm), perimCap[90][0]=0.2035 (40.7 /µm), length=4000 (20 µm)\nCapDebug (sidewall): A-B (layer li), overlap=4000 (20 µm), sep=40 (0.2 µm), e-&gt;ec_cap=12.75 (0.0255 fF), e-&gt;ec_offset=28 (0.14 µm), delta += 0.75 fF …  now is 1.5 fF\nCapDebug (obsolete_fringe (blocked)): B -= 0.737881 fF …    now B == 1.711319 fF\n    overlapMult=0.003699 (3.699 aF/µm^2) dnear=40 (0.2 µm), snear=0.0935129 (0.000467564 µm), perimCap[90][0]=0.2035 (40.7 /µm), length=4000 (20 µm)\nexttospice finished."
  },
  {
    "objectID": "doc/doc.html#test-pattern-sideoverlap_simple_plates_li1_m1",
    "href": "doc/doc.html#test-pattern-sideoverlap_simple_plates_li1_m1",
    "title": "KLayout-PEX Documentation",
    "section": "7.3 Test Pattern sideoverlap_simple_plates_li1_m1",
    "text": "7.3 Test Pattern sideoverlap_simple_plates_li1_m1\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/sideoverlap_simple_plates_li1_m1.gds.gz\n\n\n\n\n\nOverlap capacitances to substrate.\n\n\n\n\n\nExtracted Parasitic Overlap Capacitances\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nOverlap\nli1\nli1\nsubstrate\nVSUBS\n3.699\n3.7\n7\n\n\nOverlap\nmet1\nmet1\nsubstrate\nVSUBS\n232.02\n232.02\n15\n\n\n\n\n\n\n\n\nFringe capacitances li1 to substrate.\n\n\n\n\n\n\n\n\n\nFringe capacitances met1 to substrate.\n\n\n\n\n\nExtracted Parasitic Fringe Capacitances between metals and substrate\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nFringe (top)\nli1\nli1\nsubstrate\nVSUBS\n2.035\n2.035\n9\n\n\nFringe (bottom)\nli1\nli1\nsubstrate\nVSUBS\n2.035\n2.035\n11\n\n\nFringe (left)\nli1\nli1\nsubstrate\nVSUBS\n0.081\n0.081\n10\n\n\nFringe (right)\nli1\nli1\nsubstrate\nVSUBS\n0.081\n0.081\n12\n\n\nFringe (top)\nmet1\nmet1\nsubstrate\nVSUBS\n6.0855\n6.085\n17\n\n\nFringe (bottom)\nmet1\nmet1\nsubstrate\nVSUBS\n6.0855\n5.927\n19\n\n\nFringe (bottom)\nmet1\nmet1\nsubstrate\nVSUBS\n-0.1579\n—\n19\n\n\nFringe (left)\nmet1\nmet1\nsubstrate\nVSUBS\n2.4342\n2.434\n18\n\n\nFringe (right)\nmet1\nmet1\nsubstrate\nVSUBS\n2.4342\n2.434\n20\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMAGIC handles shielding differently than KPEX/2.5D, it first assumes no shield exists, and later subtracts portions to arrive at the shielded value. That’s why the bold cells differ. Line 15 - 20 accumulate contributions, whereas line 34 subtracts a contribution:\n\nLine 15: CapDebug (extNodeAreaFunc/Area) layer m1(97), net m1_10000_10000#, area=360000000 (9000 µm^2) nreg_cap += 232.02 fF\nLine 17: CapDebug (extNodeAreaFunc/Perimeter/TopSide) layer m1(97), net m1_10000_10000#, length=30000 (150 µm), nreg_cap += 6.0855 fF (now nreg_cap = 238.105 fF)\nLine 18: CapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer m1(97), net m1_10000_10000#, length=12000 (60 µm), nreg_cap += 2.4342 fF (now nreg_cap = 240.54 fF)\nLine 19: CapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer m1(97), net m1_10000_10000#, length=30000 (150 µm), nreg_cap += 6.0855 fF (now nreg_cap = 246.625 fF)\nLine 20: CapDebug (extNodeAreaFunc/Perimeter/RightSide) layer m1(97), net m1_10000_10000#, length=12000 (60 µm), nreg_cap += 2.4342 fF (now nreg_cap = 249.059 fF)\nLine 34: nreg_cap -= 0.157966 fF (now nreg_cap = 248.901 fF)\n\nComparison:\n\nKPEX/2.5D: \\(4.86834 + 0.77242 + 0.2867 = 5.9275\\)\nMAGIC: \\(6.0855 - 0.157966 = 5.9275\\)\n\n\n\n\n\n\n\n\nFringe capacitances li1 to m1.\n\n\n\n\n\n\n\n\n\nFringe capacitances m1 to li1.\n\n\n\n\n\nExtracted Parasitic Fringe Capacitances between metals\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\nLayer Top\nNet Top\nLayer Bottom\nNet Bottom\nMAGIC [fF]\nKPEX/2.5D [fF]\nMAGIC Lines\n\n\n\n\nFringe (top)\nli1\nli1\nmet1\nmet1\n0.598\n0.06\n26\n\n\nFringe (bottom)\nmet1\nmet1\nli1\nli1\n0.0654\n0.065\n36\n\n\n\nMagic 8.3 revision 486 - Compiled on `date`.\n\n----------------------------------------------------\n\nExtracting sideoverlap_simple_plates_li1_m1 into /Users/martin/Source/klayout-pex/output_sky130A/sideoverlap_simple_plates_li1_m1__sideoverlap_simple_plates_li1_m1/magic_CC/sideoverlap_simple_plates_li1_m1.ext:\n\nCapDebug (extNodeAreaFunc/Area) layer li(90), net li_34000_9000, area=4000000 (100 µm^2) nreg_cap += 3.699 fF\n\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer li(90), net li_34000_9000, length=10000 (50 µm), nreg_cap += 2.035 fF (now nreg_cap = 5.734 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer li(90), net li_34000_9000, length=400 (2 µm), nreg_cap += 0.0814 fF (now nreg_cap = 5.8154 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer li(90), net li_34000_9000, length=10000 (50 µm), nreg_cap += 2.035 fF (now nreg_cap = 7.8504 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer li(90), net li_34000_9000, length=400 (2 µm), nreg_cap += 0.0814 fF (now nreg_cap = 7.9318 fF)\nCapDebug (extSetResist): li_34000_9000 area=4000000 (100 µm^2) perim=20800 (104 µm)\nCapDebug ---\nCapDebug (extNodeAreaFunc/Area) layer m1(97), net m1_10000_10000#, area=360000000 (9000 µm^2) nreg_cap += 232.02 fF\n\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer m1(97), net m1_10000_10000#, length=30000 (150 µm), nreg_cap += 6.0855 fF (now nreg_cap = 238.105 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer m1(97), net m1_10000_10000#, length=12000 (60 µm), nreg_cap += 2.4342 fF (now nreg_cap = 240.54 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer m1(97), net m1_10000_10000#, length=30000 (150 µm), nreg_cap += 6.0855 fF (now nreg_cap = 246.625 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer m1(97), net m1_10000_10000#, length=12000 (60 µm), nreg_cap += 2.4342 fF (now nreg_cap = 249.059 fF)\nCapDebug (extSetResist): m1_10000_10000# area=360000000 (9000 µm^2) perim=84000 (420 µm)\nCapDebug ---\nCapDebug (extSideOverlapHalo): (li-m1) length=30.000000 µm, mult=0.011420, dnear=3.000000 µm (600), dfar=8.000000 µm (1600), snear=0.907713, sfar=0.965163 (cfrac=0.057450)\nCapDebug (extSideOverlapHalo) (li-substrate): mult=0.003699, snear=0.730477, sfar=0.893413 (sfrac=0.162935)\nCapDebug (extSideOverlapHalo): efflength=1.72351 µm, cap+=0.299029 aF, cap=59.8059 aF, e-&gt;ec_cap=0.1735, so_coupfrac=0, subfrac+=0, subfrac=0, so_subfrac=0\nCapDebug (sideoverlaphalo): met1-li1 += 0.059806 fF …   now met1-li1 == 0.059806 fF\nCapDebug ---\nCapDebug (extSideOverlapHalo): (m1-li) length=30.000000 µm, mult=0.011420, dnear=3.000000 µm (600), dfar=5.000000 µm (1000), snear=0.907713, sfar=0.944366 (cfrac=0.036653)\nCapDebug (extSideOverlapHalo) (m1-substrate): mult=0.002578, snear=0.634619, sfar=0.764408 (sfrac=0.129789)\nCapDebug (extSideOverlapHalo): efflength=1.0996 µm, cap+=0.327131 aF, cap=65.4263 aF, e-&gt;ec_cap=0.2975, so_coupfrac=0, subfrac+=0, subfrac=0, so_subfrac=0\nCapDebug (extSideOverlapHalo/obsolete_perimcap) layer m1(97), net met1, \n    efflength=3.89366 µm (778.733) = (sfrac(0.129789) - subfrac(0)) * length(30 µm)\n    exts_perimCap[m1][0] = 0.20285\n    nreg_cap -= 0.157966 fF (now nreg_cap = 248.901 fF)\nCapDebug (obsolete_perimcap): met1 -= 0.157966 fF … now met1 == 248.901423 fF\nCapDebug (sideoverlaphalo): met1-li1 += 0.065426 fF …   now met1-li1 == 0.125232 fF"
  },
  {
    "objectID": "doc/doc.html#test-pattern-r_single_wire_li1",
    "href": "doc/doc.html#test-pattern-r_single_wire_li1",
    "title": "KLayout-PEX Documentation",
    "section": "7.4 Test Pattern r_single_wire_li1",
    "text": "7.4 Test Pattern r_single_wire_li1\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/r_single_wire_li1.gds.gz\n\n\n\n\n\nResistance of a single wire on li1.\n\n\n\n\n\nWire length \\(L = 9.85\\,\\mu m\\)\nWire height \\(H = 0.15\\,\\mu m\\)\nLayer is li1\nParasitic Table Coefficient \\(R_{coeff}(li1) = 12800\\,mΩ\\)\n\nIf we apply the formula illustrated in Section 5.8.1, we get \\[\nR_{wire} = \\frac{L}{H} * R_{coeff}\n\\] \\[\nR_{wire} = \\frac{9.85\\,\\mu m}{0.15\\,\\mu m} * 12800\\,mΩ = 8405\\dot{3}\\,mΩ = 840.5\\dot{3}\\,Ω\n\\]\nMagic 8.3 revision 486 - Compiled on `date`.\n----------------------------------------------------\n...\nWarning:  Ports \"A\" and \"B\" are electrically shorted.\n\nLocation is (1970, -15); drivepoint (1970, -15)\nLocation is (0, -15); drivepoint (0, -15)\n\nResCalcEastWest: A (0, -0.075) &lt;-&gt; B (9.85, -0.075) @ li\n    exts_sheetResist[li]=12800, length=9.85, height=0.15, resistor-&gt;rr_value = 840533 mΩ\nResCalcEastWest: A (0, -0.075) &lt;-&gt; B (9.85, -0.075) @ li\n    exts_sheetResist[li]=12800, length=9.85, height=0.15, resistor-&gt;rr_value = 840533 mΩ\nTotal Nets: 2\n\n\n\n\n\n\nNote\n\n\n\nMAGIC recognizes that ports A and B are shorted. The purpose of these test patterns is to look at minimized problems in isolation, like the resistance of the wire here. They are not realistic examples, so it appears to be a bug in that corner case, that the resistance is reported twice."
  },
  {
    "objectID": "doc/doc.html#test-pattern-r_contact_1x1_minsize_mcon",
    "href": "doc/doc.html#test-pattern-r_contact_1x1_minsize_mcon",
    "title": "KLayout-PEX Documentation",
    "section": "7.5 Test Pattern r_contact_1x1_minsize_mcon",
    "text": "7.5 Test Pattern r_contact_1x1_minsize_mcon\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/r_contact_1x1_minsize_mcon.gds.gz\n\n\n\n\n\nResistance of a minimum sized via on mcon.\n\n\n\n\n\nLayers:\n\nTop Layer: met1\nVia: mcon\nBottom Layer: li1\n\nDesign rules:\n\nVia width: \\(viawidth = 0.17\\,\\mu m\\)\nVia spacing: \\(spacing = 0.19\\,\\mu m\\)\nVia border: \\(border = 0.0\\,\\mu m\\)\n\nParasitic Table Coefficient \\(R_{coeff}(mcon) = 9300\\,mΩ\\)\nDrawn via:\n\n\\(w = 0.17\\,\\mu m\\)\n\\(h = 0.17\\,\\mu m\\)\n\n\nIf we apply the formula illustrated in Section 5.8.2, we get\n\\[\nn_x = 1 + \\left\\lfloor\\frac{w - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\\[\nn_x = 1 + \\left\\lfloor\\frac{0.17\\,\\mu m - (0.17 + 2 * 0.0)\\,\\mu m}{0.17\\,\\mu m + 0.19\\,\\mu m}\\right\\rfloor = 1\n\\]\n\\[\nn_y = 1 + \\left\\lfloor\\frac{h - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\\[\nn_y = 1 + \\left\\lfloor\\frac{0.17\\,\\mu m - (0.17 + 2 * 0.0)\\,\\mu m}{0.17\\,\\mu m + 0.19\\,\\mu m}\\right\\rfloor = 1\n\\]\n\\[\nR_{via} = \\frac{R_{coeff}}{n_x * n_y}   \\,\\,\\,\\,\\,\\,\\, \\left[\\frac{mΩ}{\\text{via count}}\\right]\n\\]\n\\[\nR_{via} = \\frac{9300\\,mΩ}{1 * 1} = 9300\\,mΩ = 9.3\\,Ω\n\\]\nMagic 8.3 revision 486 - Compiled on `date`.\n----------------------------------------------------\n...\nWarning:  Ports \"TOP\" and \"BOT\" are electrically shorted.\nLocation is (0, 0); drivepoint (0, 0)\nLocation is (0, 0); drivepoint (0, 0)\n\nResDoContacts: (null) (0.085, 0.085) &lt;-&gt; (null) (0.085, 0.085) @ v0\n    W = 0.17 µm, H = 0.17 µm\n    exts_viaResist[v0]=9300, viawidth=0.17 µm, spacing=0.19 µm, border=0 µm\n    squaresx=1, squaresy=1, resistor-&gt;rr_value = 9300 mΩ"
  },
  {
    "objectID": "doc/doc.html#test-pattern-r_contact_2x2_minsize_mcon",
    "href": "doc/doc.html#test-pattern-r_contact_2x2_minsize_mcon",
    "title": "KLayout-PEX Documentation",
    "section": "7.6 Test Pattern r_contact_2x2_minsize_mcon",
    "text": "7.6 Test Pattern r_contact_2x2_minsize_mcon\nGDS: https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/r_contact_2x2_minsize_mcon.gds.gz\n\n\n\n\n\nResistance of a minimum sized 2x2 via on mcon.\n\n\n\n\n\nLayers:\n\nTop Layer: met1\nVia: mcon\nBottom Layer: li1\n\nDesign rules:\n\nVia width: \\(viawidth = 0.17\\,\\mu m\\)\nVia spacing: \\(spacing = 0.19\\,\\mu m\\)\nVia border: \\(border = 0.0\\,\\mu m\\)\n\nParasitic Table Coefficient \\(R_{coeff}(mcon) = 9300\\,mΩ\\)\nDrawn via:\n\n\\(w = 0.53\\,\\mu m\\)\n\\(h = 0.53\\,\\mu m\\)\n\n\nIf we apply the formula illustrated in Section 5.8.2, we get\n\\[\nn_x = 1 + \\left\\lfloor\\frac{w - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\\[\nn_x = 1 + \\left\\lfloor\\frac{0.53\\,\\mu m - (0.17 + 2 * 0.0)\\,\\mu m}{0.17\\,\\mu m + 0.19\\,\\mu m}\\right\\rfloor = 1 + \\left\\lfloor 1.0\\right\\rfloor = 2\n\\]\n\\[\nn_y = 1 + \\left\\lfloor\\frac{h - (viawidth + 2 * border)}{viawidth + spacing}\\right\\rfloor\n\\]\n\\[\nn_y = 1 + \\left\\lfloor\\frac{0.53\\,\\mu m - (0.17 + 2 * 0.0)\\,\\mu m}{0.17\\,\\mu m + 0.19\\,\\mu m}\\right\\rfloor = 1 + \\left\\lfloor 1.0\\right\\rfloor = 2\n\\]\n\\[\nR_{via} = \\frac{R_{coeff}}{n_x * n_y}   \\,\\,\\,\\,\\,\\,\\, \\left[\\frac{mΩ}{\\text{via count}}\\right]\n\\]\n\\[\nR_{via} = \\frac{9300\\,mΩ}{2 * 2} = 2325\\,mΩ = 2.325\\,Ω\n\\]\nMagic 8.3 revision 486 - Compiled on `date`.\n----------------------------------------------------\n...\nWarning:  Ports \"TOP\" and \"BOT\" are electrically shorted.\n...\nResDoContacts: (null) (0.265, 0.265) &lt;-&gt; (null) (0.265, 0.265) @ v0\n    W = 0.53 µm, H = 0.53 µm\n    exts_viaResist[v0]=9300, viawidth=0.17 µm, spacing=0.19 µm, border=0 µm\n    squaresx=2, squaresy=2, resistor-&gt;rr_value = 2325 mΩ\n ::: {.content-hidden} Copyright (C) 2024 Martin Köhler and co-authors (martin.koehler@jku.at)\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. :::"
  },
  {
    "objectID": "doc/doc.html#ticer-algorithm-time-constant-equilibration-reduction",
    "href": "doc/doc.html#ticer-algorithm-time-constant-equilibration-reduction",
    "title": "KLayout-PEX Documentation",
    "section": "8.1 TICER algorithm: TIme-Constant Equilibration Reduction",
    "text": "8.1 TICER algorithm: TIme-Constant Equilibration Reduction\nThis section reviews the original TICER paper (B. N. Sheehan 1999), and illustrates the main ideas.\nGiven \\(N\\)-terminal star network:\n\nnode \\(N\\) is the center\nterminals labeled from \\(0\\) to \\(N\\!-\\!1\\) (in Figure 6, \\(m\\) is used instead of \\(N\\!-\\!1\\))\neach branch, going from the terminal \\(T_i\\) to \\(N\\), contains a resistor and a capacitor in parallel\nresistor values are given as conductance (easier parallel summation): \\(g_{ij}\\,\\,[\\mho]\\)\n\ncapacitances values: \\(c_{ij}\\,\\,[F]\\)\n\n\n\n\n\n\n\nFigure 6: N-terminal star network\n\n\n\nSum of resistances \\(\\gamma_N\\), and capacitances \\(\\chi_N\\):\n\\[\n\\gamma_N = \\sum_{k=0}^{N-1} g_{kN}, \\quad \\chi_N = \\sum_{k=0}^{N-1} c_{kN}\n\\tag{1.2}\n\\]\nThe time constant \\(\\tau_N\\) of a given node \\(N\\) then is: \\[\n\\tau_N = \\frac{\\chi_N}{\\gamma_N} = \\frac{\\sum_{k=0}^{N-1} c_{kN}}{\\sum_{k=0}^{N-1} g_{kN}}   \\tag{1.3}\n\\]\nBasic node elimination idea: Given a desired frequency window, using the time-constants, we can classify nodes into 3 groups: slow / normal / quick. Then we can eliminate slow and quick nodes, as the normal nodes will suffice to preserve the behavior for the frequency window:\nRC circuit in Laplace domain: \\[\n(s \\mathbf{C} + \\mathbf{G})\\mathbf{v} = \\mathbf{Y} \\mathbf{v} = \\mathbf{J}  \\tag{2.1}\n\\]\n\n\\(s \\in \\mathbb{C}\\): Complex Frequency\n\\(\\mathbf{C} \\in \\mathbb{R}^{N-1 \\times N-1}\\): nodal capacitances\n\\(\\mathbf{G} \\in \\mathbb{R}^{N-1 \\times N-1}\\): nodal conductances\n\\(\\mathbf{v} \\in \\mathbb{R}^{N-1}\\): nodal voltages\n\\(\\mathbf{J} \\in \\mathbb{R}^{N-1}\\): current sources at the nodes\n\nThis can be written as a block system: \\[\n\\begin{bmatrix}\n\\mathbf{\\tilde{Y}} & \\mathbf{y} \\\\\n\\mathbf{y}^T & s\\chi_N + \\gamma_N\n\\end{bmatrix}\n\\begin{bmatrix}\n\\tilde{\\mathbf{v}} \\\\\nv_N\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\tilde{\\mathbf{J}} \\\\\nj_N\n\\end{bmatrix}\n\\tag{2.2}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nIn equation (2.2), Sheehan uses the tilde accent to name the remainder of the matrix \\(\\mathbf{Y}\\) as \\(\\mathbf{\\tilde{Y}}\\), when looking only at the last row and column (same principle applies to vector \\(\\mathbf{v}\\) and \\(\\mathbf{\\tilde{v}}\\)): \\[\\begin{equation}\n\\mathbf{Y} =\n\\left[\n\\begin{array}{cccc:c}\ny_{11} & y_{12} & \\cdots & y_{1,N-1} & y_{1N} \\\\\ny_{21} & y_{22} & \\cdots & y_{2,N-1} & y_{2N} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots   & \\vdots \\\\\n\\hdashline\ny_{N1} & y_{N} & \\cdots & y_{N,N-1} & y_{NN}\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}{c:c}\n\\mbox{\\LARGE $\\mathbf{\\tilde{Y}}$} &\n\\begin{array}{c}\ny_{1N} \\\\\ny_{2N} \\\\\n\\vdots\n\\end{array} \\\\ \\hdashline\n\\begin{array}{cccc}\ny_{N1} & y_{N2} & \\cdots & y_{N,N-1}\n\\end{array}\n&\ny_{NN}\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}{c:c}\n\\mbox{\\LARGE $\\mathbf{\\tilde{Y}}$} &\n\\mbox{\\LARGE $\\mathbf{y}$} \\\\ \\hdashline\n\\mbox{\\LARGE $\\mathbf{y}^T$}\n&\ny_{NN}\n\\end{array}\n\\right]\n\\end{equation}\\]\n\n\n\n8.1.1 Comments on page 2, equation \\((2.3)\\)\nTo arrive at equations (2.3), (2.4), and (2.5) from equation (2.2), the process involves solving for \\(v_N\\), the voltage at the node to be eliminated (node \\(N\\)), and substituting it back into the system of equations.\nStarting with equation (2.2):\n\\[\n\\begin{bmatrix}\n\\mathbf{\\tilde{Y}} & \\mathbf{y} \\\\\n\\mathbf{y}^T & s\\chi_N + \\gamma_N\n\\end{bmatrix}\n\\begin{bmatrix}\n\\tilde{\\mathbf{v}} \\\\\nv_N\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\tilde{\\mathbf{J}} \\\\\nj_N\n\\end{bmatrix}\n\\tag{2.2}\n\\]\nwe have two block equations:\n\\[\n   \\mathbf{\\tilde{Y}} \\tilde{\\mathbf{v}} + \\mathbf{y} v_N = \\tilde{\\mathbf{J}}\n\\tag{\\small First block equation of 2.2}\n\\]\n\\[\n   \\mathbf{y}^T \\tilde{\\mathbf{v}} + (s\\chi_N + \\gamma_N) v_N = j_N\n\\tag{\\small Second block equation of 2.2}\n\\]\nSolve the second block equation for \\(v_N\\): \\[\n   v_N = \\frac{j_N - \\mathbf{y}^T \\tilde{\\mathbf{v}}}{s\\chi_N + \\gamma_N}\n   \\]\nSubstitute the expression for \\(v_N\\) in the first block equation:\n\\[\n   \\mathbf{\\tilde{Y}} \\tilde{\\mathbf{v}} + \\mathbf{y} \\left(\\frac{j_N - \\mathbf{y}^T \\tilde{\\mathbf{v}}}{s\\chi_N + \\gamma_N}\\right) = \\tilde{\\mathbf{J}}\n   \\] Simplifying, we get: \\[\n   \\left(\\mathbf{\\tilde{Y}} - \\frac{\\mathbf{y} \\mathbf{y}^T}{s\\chi_N + \\gamma_N}\\right) \\tilde{\\mathbf{v}} = \\tilde{\\mathbf{J}} - \\frac{\\mathbf{y} j_N}{s\\chi_N + \\gamma_N}\n   \\]\nThis leads to the modified system: \\[\n(\\tilde{Y} - \\mathbf{E}) \\tilde{\\mathbf{v}} = \\tilde{\\mathbf{J}} - \\mathbf{F}\n\\tag{2.3}\n\\]\nWhere:\n\\[\n\\mathbf{E} = \\frac{\\mathbf{y} \\mathbf{y}^T}{s\\chi_N + \\gamma_N}\n\\]\n\\[\n\\mathbf{F} = \\frac{\\mathbf{y} j_N}{s\\chi_N + \\gamma_N}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThere’s a typo in the original paper in (2.3), the printed variable \\(\\mathbf{v_N}\\) should instead be \\(\\mathbf{\\tilde{v}}\\).\n\n\nSo we arrive at: \\[\n\\mathbf{E}_{ij} = \\frac{(g_{iN} + s c_{iN})(g_{jN} + s c_{jN})}{s\\chi_N + \\gamma_N}\n\\tag{2.4}\n\\] \\[\n\\mathbf{F}_{i} = \\frac{g_{iN} + s c_{iN}}{s\\chi_N + \\gamma_N} j_N\n\\tag{2.5}\n\\]\n\n\n8.1.2 Quick Nodes\nSuppose:\n\nwe eliminate a quick node \\(N\\)\n\\(s\\chi_N \\ll \\gamma_N\\)\nequivalently, \\(|s \\tau_N| \\ll 1\\)\nwe approximate \\(\\mathbf{E}_{ij}\\) from (2.4)\nwe eliminate higher-order terms, containing factors like \\(s^n\\) for \\(n \\ge 2\\)\n\n\\[\n\\begin{aligned}\n\\mathbf{E}_{ij} &= \\frac{(g_{iN} + s c_{iN})(g_{jN} + s c_{jN})}{s\\chi_N + \\gamma_N} \\\\\n                &= \\frac{g_{iN}g_{jN}}{s\\chi_N + \\gamma_N} + \\frac{s \\left( g_{jN} c_{iN} + g_{iN} c_{jN} \\right)}{s\\chi_N + \\gamma_N} + \\frac{s^2 c_{iN} c_{jN}}{s\\chi_N + \\gamma_N}\n\\end{aligned}\n\\]\n\\[\n\\mathbf{E}_{ij} \\approx \\frac{g_{iN}g_{jN}}{\\cancel{s\\chi_N} + \\gamma_N} + s\\frac{g_{jN} c_{iN} +  g_{iN} c_{jN}}{\\cancel{s\\chi_N} + \\gamma_N} + \\cancel{\\frac{s^2 c_{iN} c_{jN}}{s\\chi_N + \\gamma_N}}\n\\]\n\\[\n\\mathbf{E}_{ij} \\approx \\frac{g_{iN}g_{jN}}{\\gamma_N} + s\\frac{g_{jN} c_{iN} +  g_{iN} c_{jN}}{\\gamma_N}   \\tag{3.2}\n\\]\nEliminating a quick node:\nRecipe for translating (3.2) into a modified circuit:\n\nremove all resistors and capacitors connecting other nodes to \\(N\\)\ninsert new resistors and capacitors between former neighbors \\(i\\), \\(j\\) of \\(N\\) according to these rules:\n\nIf nodes \\(i\\) and \\(j\\) had been connected to \\(N\\) through conductances \\(g_{iN}\\) and \\(g_{jN}\\), insert conductance \\(\\frac{g_{iN} g_{jN}}{\\gamma_N}\\) between \\(i\\) and \\(j\\)\nIf node \\(i\\) had a capacitor \\(c_{iN}\\) to \\(N\\), and node \\(j\\) had a conductance \\(g_{jN}\\) to \\(N\\), insert a capacitor \\(\\frac{c_{iN} g_{jN}}{\\gamma_N}\\) between \\(i\\) and \\(j\\)\n\n\n\n\n8.1.3 Slow Nodes\nSuppose:\n\nwe eliminate a slow node \\(N\\)\n\\(s\\chi_N \\gg \\gamma_N\\)\nequivalently, \\(|s \\tau_N| \\gg 1\\)\nwe approximate \\(\\mathbf{E}_{ij}\\) from (2.4)\nwe retain terms containing \\(s\\)\nto preserve DC characteristics, we use \\(\\frac{g_{iN}g_{jN}}{\\gamma_N}\\) in place of whatever constant terms come from the equation\nhigher-order terms in \\(\\gamma_N\\) and \\(s\\) are neglected to simplify the expression.\n\nStarting with (2.4):\n\\[\n\\mathbf{E}_{ij} = \\frac{(g_{iN} + s c_{iN})(g_{jN} + s c_{jN})}{s\\chi_N + \\gamma_N}\n\\tag{2.4}\n\\]\nGiven the approximation:\n\\[\n\\frac{1}{s \\chi_N + \\gamma_N} \\approx \\frac{1}{s \\chi_N} \\left( 1 - \\frac{\\gamma_N}{s \\chi_N} \\right)\n\\tag{4.2}\n\\]\nSubstitute (4.2) into (2.4):\n\\[\n\\begin{aligned}\n\\mathbf{E}_{ij} &\\approx \\frac{(g_{iN} + s c_{iN})(g_{jN} + s c_{jN})}{s\\chi_N}\\left(1 - \\frac{\\gamma_N}{s\\chi_N}\\right) \\\\\n                &\\approx \\left(\\frac{g_{iN}g_{jN}}{s\\chi_N} + \\frac{\\cancel{s} \\left( g_{jN} c_{iN} + g_{iN} c_{jN} \\right)}{\\cancel{s}\\chi_N} + \\frac{s\\cancel{^2} c_{iN} c_{jN}}{\\cancel{s}\\chi_N}\\right)\\left(1 - \\frac{\\gamma_N}{s\\chi_N}\\right) \\\\\n\\end{aligned}\n\\]\nExpand:\n\\[\n\\begin{aligned}\n\\mathbf{E}_{ij} &= \\frac{g_{iN}g_{jN}}{s\\chi_N} - \\frac{g_{iN}g_{jN} \\gamma_N}{s^2 \\chi_N^2} \\\\\n                &+ \\frac{g_{jN} c_{iN} + g_{iN} c_{jN}}{\\chi_N} - \\frac{\\left( g_{jN} c_{iN} + g_{iN} c_{jN} \\right) \\gamma_N}{s\\chi_N^2} \\\\\n                &+ \\frac{s c_{iN} c_{jN}}{\\chi_N} - \\frac{\\cancel{s} c_{iN} c_{jN} \\gamma_N}{\\cancel{s}\\chi_N^2}\n\\end{aligned}\n\\]\nAfter we remove constant terms:\n\\[\n\\begin{aligned}\n\\mathbf{E}_{ij} &\\approx \\frac{g_{iN}g_{jN}}{s\\chi_N} - \\frac{g_{iN}g_{jN} \\gamma_N}{s^2 \\chi_N^2} - \\frac{\\left( g_{jN} c_{iN} + g_{iN} c_{jN} \\right) \\gamma_N}{s\\chi_N^2} + s \\frac{c_{iN} c_{jN}}{\\chi_N}\n\\end{aligned}\n\\]\nRemove higher-order terms in \\(\\gamma_N\\) and \\(s\\):\n\\[\n\\begin{aligned}\n\\mathbf{E}_{ij} &\\approx \\frac{g_{iN}g_{jN}}{s\\chi_N} + s \\frac{c_{iN} c_{jN}}{\\chi_N}\n\\end{aligned}\n\\]\nSheehan arrives at (4.1):\n\\[\n\\mathbf{E}_{ij} \\approx \\frac{g_{iN}g_{jN}}{\\gamma_N} + s\\frac{c_{iN} c_{jN}}{\\chi_N}\n\\tag{4.1}\n\\]\n\\[\n\\textcolor{red}{\\text{TODO: why not }\\frac{g_{iN} g_{jN}}{s\\chi_N} \\text{?}}\n\\]\n\nRules:\n\nIf nodes \\(i\\) and \\(j\\) had been connected to \\(N\\) through conductances \\(g_{iN}\\) and \\(g_{jN}\\), insert conductance \\(\\frac{g_{iN} g_{jN}}{\\gamma_N}\\) from \\(i\\) to \\(j\\)\nIf node \\(i\\) had a capacitor \\(c_{iN}\\) to \\(N\\), and node \\(j\\) had a capacitor \\(c_{jN}\\) to \\(N\\), insert a capacitor \\(\\frac{c_{iN} c_{jN}}{\\gamma_N}\\) from \\(i\\) to \\(j\\)\n\n\n\\[\n\\textcolor{red}{\\text{TODO: why not }\\frac{c_{iN} c_{jN}}{\\chi_N} \\text{?}}\n\\]"
  },
  {
    "objectID": "doc/doc.html#ticer-2007-paper-pseudocode",
    "href": "doc/doc.html#ticer-2007-paper-pseudocode",
    "title": "KLayout-PEX Documentation",
    "section": "8.2 TICER 2007 paper: Pseudocode",
    "text": "8.2 TICER 2007 paper: Pseudocode\nThis section reviews some aspects of the 2007 TICER paper (Bernard N. Sheehan 2007).\nUser-supplied algorithm parameters:\n\nSet of \\(\\mathbf{fixed}\\) nodes (designated to be left alone, i.e., not to be eliminated)\n\\(\\mathbf{MaxDeg} \\in \\mathbb{N}\\!\\setminus\\!\\{0, 1\\}\\): number of passes (user-supplied parameter)\n\\(f^{\\text{max}}\\): maximum operating frequency of interest\n\\(\\epsilon \\in \\mathbb{R}_{[0,1]}\\): small number enforcing the requirement that \\(|s \\tau_N| \\ll 1\\)\n\nIn the paper, figure 5 and 6 demonstrate the algorithm for eliminating a quick node (here is a python conversion of those).\ndef eliminate_quick_node(N: Node):\n   neighbors = nodes_incident_to(node=N)\n   for i in neighbors:\n      g_iN = conductance[i, N]\n      if g_iN == 0: \n         continue\n      for j in neighbors:\n         if i &lt;= j:\n            continue\n         g_jN = conductance[j, N]\n         c_jN = capacitance[j, N]\n         gamma_N = incident_conductance_sum(node=N)\n         if g_jN &gt; 0:\n            add_conductance(i, j, g_iN * g_jN / gamma_N)\n         if c_jN &gt; 0:\n            add_capacitance(i, j, g_iN * c_jN / gamma_N)\n   remove_all_incident_conductances_and_capacitances(i, N)\ndef ticer(freq_max: float, epsilon: float, max_deg: int):\n   for deg in range(2, max_deg):\n      Q = queue.Queue(nodes_not_fixed())\n      while not Q.empty():\n         N = Q.get()  # pop\n         if number_of_incident_resistors(N) &gt; deg:\n            continue\n         tau_N = time_constant(N)\n         if 2 * math.pi * freq_max * tau_N &lt;= epsilon:\n            # ensure the neighbors are in the queue,\n            # because the neighbors' incident resistors and time constants \n            # might have been changed, so they should be reconsidered for elimination\n            missing_neighbors = [n in nodes_incident_to(node=N) if n not in Q]\n            q.push(missing_neighbors)\n\n            eliminate_quick_node(N)\n\n   # NOTE: \"leaf node\" N means, number_of_incident_resistors(N) == 1\n   for N in leaf_nodes():\n      if N in fixed_nodes():  # N is protected\n         continue\n\n      tau_N = time_constant(N)\n      if 2 * math.pi * freq_max * tau_N &lt;= epsilon:\n         eliminate_quick_node(N)\n\n8.2.1 Pseudocode for slow node elimination\nSheehan mentions that elimination of slow nodes is of reduced importances, and therefore does not explicitly provide pseudocode for this case, instead refers to the original TICER paper (B. N. Sheehan 1999).\nSo if we fill in the gaps we arrive at:\ndef eliminate_slow_node(N: Node):\n   neighbors = nodes_incident_to(node=N)\n   for i in neighbors:\n      g_iN = conductance[i, N]\n      c_iN = capacitance[i, N]\n      for j in neighbors:\n         if i &lt;= j:\n            continue\n         g_jN = conductance[j, N]\n         c_jN = capacitance[j, N]\n         gamma_N = incident_conductance_sum(node=N)\n         if g_iN &gt; 0 and g_jN &gt; 0:\n            add_conductance(i, j, g_iN * g_jN / gamma_N)\n         if c_iN &gt; 0 and c_jN &gt; 0:\n            add_capacitance(i, j, c_iN * c_jN / gamma_N)\n   remove_all_incident_conductances_and_capacitances(i, N)\nTo integrate this into the algorithm, we additionally need a minimum frequency \\(f^{\\text{min}}\\) parameter supplied by the user.\ndef ticer(freq_min: float, freq_max: float, epsilon: float, max_deg: int):\n   for deg in range(2, max_deg):\n      Q = queue.Queue(nodes_not_fixed())\n      while not Q.empty():\n         N = Q.get()  # pop\n         if number_of_incident_resistors(N) &gt; deg:\n            continue\n         tau_N = time_constant(N)\n         if 2 * math.pi * freq_max * tau_N &lt;= epsilon:\n            # NOTE: ensure the neighbors are in the queue,\n            # because the neighbors' incident resistors and time constants \n            # might have been changed, so they should be reconsidered for elimination\n            missing_neighbors = [n in nodes_incident_to(node=N) if n not in Q]\n            q.push(missing_neighbors)\n\n            eliminate_quick_node(N)\n\n         if 2 * math.pi * freq_min * tau_N &lt;= epsilon:\n            # NOTE: ensure the neighbors are in the queue,\n            # because the neighbors' incident resistors and time constants \n            # might have been changed, so they should be reconsidered for elimination\n            missing_neighbors = [n in nodes_incident_to(node=N) if n not in Q]\n            q.push(missing_neighbors)\n\n            eliminate_slow_node(N)\n\n   # NOTE: \"leaf node\" N means, number_of_incident_resistors(N) == 1\n   for N in leaf_nodes():\n      if N in fixed_nodes():  # N is protected\n         continue\n\n      tau_N = time_constant(N)\n      if 2 * math.pi * freq_max * tau_N &lt;= epsilon:\n         eliminate_quick_node(N)"
  },
  {
    "objectID": "doc/doc.html#example-from-ticer-2007-paper",
    "href": "doc/doc.html#example-from-ticer-2007-paper",
    "title": "KLayout-PEX Documentation",
    "section": "8.3 Example from TICER 2007 paper",
    "text": "8.3 Example from TICER 2007 paper\nLet’s reduce the example presented by Sheehan in the from the 2007 paper (Bernard N. Sheehan 2007), as shown in Figure 7. The goal is to eliminate the quick node \\(v_3\\).\n\n\n\n\n\n\n\n\nFigure 7: Passive RC circuit shown in Bernard N. Sheehan (2007).\n\n\n\n\n\n\nTime constant \\(\\tau_{v_3} = \\frac{c_3}{g_{13} + g_{23}}\\)\nQuick node condition: \\(\\text{is\\_quick}(N) := 2 \\pi f^{\\text{max}} \\tau_N &lt; \\epsilon\\)\n\nElimination of node \\(N_2\\):\n\nIncident devices \\(R_{13}\\), \\(R_{23}\\), \\(C_{3}\\) are removed\nNew devices for neighbors\n\nBetween nodes \\((v_0, v_1)\\):\n\nadd \\(c_{10} = \\frac{g_{13}*c_{3}}{g_{13} + g_{23}}\\)\n\nBetween nodes \\((v_0, v_2)\\):\n\nadd \\(c_{20} = \\frac{g_{23}*c_{3}}{g_{13} + g_{23}}\\)\n\nBetween nodes \\((v_1, v_2)\\):\n\nadd \\(g_{12} = \\frac{g_{13}*g_{23}}{g_{13} + g_{23}}\\)\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Passive RC circuit after the elimination of \\(v_3\\).\n\n\n\n\n\nRC circuit in Laplace domain:\n\\[\n(s \\mathbf{C} + \\mathbf{G})\\mathbf{v} = \\mathbf{Y} \\mathbf{v} = \\mathbf{J}  \\tag{2.1}\n\\]\nSolve for voltages:\n\\[\n\\mathbf{v} = (s \\mathbf{C} + \\mathbf{G})^{-1} \\mathbf{J} = Y^{-1} \\mathbf{J}\n\\]\nTransfer function:\n\\[\nH(s) = \\frac{\\mathbf{v}(s)}{\\mathbf{J}(s)} = Y^{-1}(s) = (s \\mathbf{G} + \\mathbf{C})^{-1}\n\\]\nE.g. the transfer function (for input \\(J_1(s)\\), output \\(V_2(s)\\)) is:\n\\[\nH(s) = \\frac{\\text{adj}(s \\mathbf{C} + \\mathbf{G})_{21}}{det(s \\mathbf{C} + \\mathbf{G})}\n\\]\n\n8.3.1 Analysis of the original circuit\nSo for the original circuit of Figure 7, we have 3 nodes, in addition to GND (\\(v_0\\)).\nSo we have 3 nodal equations:\n\\[\n\\begin{aligned}\nc_1 \\dot{v_1} + g_d v_1 + g_{13} (v_1 - v_3)              &= j_1(t) \\\\\nc_2 \\dot{v_2} + g_{23} (v_2 - v_3)                        &= 0      \\\\\nc_3 \\dot{v_3} + g_{13} (v_3 - v_1) + g_{23} * (v_3 - v_2) &= 0\n\\end{aligned}\n\\]\nLaplace domain (MNA7 form):\n\\[\n\\left(\ns\n\\left[\n\\begin{array}{ccc}\nc_1 &   0 &   0 \\\\\n  0 & c_2 &   0 \\\\\n  0 &   0 & c_3\n\\end{array}\n\\right]\n+\n\\left[\n\\begin{array}{cccc}\ng_d + g_{13}  &        0 & -g_{13}         \\\\\n0             &   g_{23} & -g_{23}         \\\\\n-g_{13}       &  -g_{23} & g_{13} + g_{23}\n\\end{array}\n\\right]\n\\right)\n\\left[\n\\begin{array}{c}\nV_{1}(s) \\\\\nV_{2}(s) \\\\\nV_{3}(s)\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}{c}\nJ_{1}(s) \\\\\n0 \\\\\n0\n\\end{array}\n\\right]\n\\]\nSo given the values from Sheehan’s numerical example:\n\n\\(g_d = g_{13} = g_{23} = 1\\)\n\\(c_1 = c_2 = 1\\)\n\\(c_3 = 0.01\\)\n\nNode \\(v_3\\) is a quick node:\n\nTime constant: \\(\\tau_{v_3} = \\frac{c_3}{g_{13} + g_{23}} = \\frac{0.001}{1 + 1} = 0.0005\\)\nFrequency: \\(f = \\frac{1}{2 \\pi \\tau_{v_3}} \\approx 318.31\\,\\text{Hz}\\)\n\nWe have a system with \\[\n\\mathbf{C} =\n\\left[\n\\begin{array}{ccc}\n  1 &   0 &    0 \\\\\n  0 &   1 &    0 \\\\\n  0 &   0 & 0.01\n\\end{array}\n\\right],\n\\mathbf{G} =\n\\left[\n\\begin{array}{ccc}\n   2 &   0 & -1 \\\\\n   0 &   1 & -1 \\\\\n  -1 &  -1 &  2\n\\end{array}\n\\right]\n\\]\nTransfer function:\n\\[\nH(s) = \\frac{1}{0.01s^3 + 2.03s^2 + 4.02s + 1}\n\\]\n\n\n8.3.2 Analysis of the reduced circuit\nThe reduced circuit in Figure 8 only has 2 remaining nodes (besides GND).\nSo we have 2 nodal equations:\n\\[\n\\begin{aligned}\n(c_1 + c_{10}) \\dot{v_1} + g_d v_1 + g_{12} (v_1 - v_2)   &= j_1(t) \\\\\n(c_2 + c_{20}) \\dot{v_2} + g_{12} (v_2 - v_1)             &= 0\n\\end{aligned}\n\\]\nLaplace domain (MNA8 form):\n\\[\n\\left(\ns\n\\left[\n\\begin{array}{cc}\nc_1 + c_{10} &            0 \\\\\n           0 & c_2 + c_{20}\n\\end{array}\n\\right]\n+\n\\left[\n\\begin{array}{cccc}\ng_d + g_{12}  & -g_{12}         \\\\\n-g_{12}       &  g_{12}\n\\end{array}\n\\right]\n\\right)\n\\left[\n\\begin{array}{c}\nV_{1}(s) \\\\\nV_{2}(s)\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}{c}\nJ_{1}(s) \\\\\n0\n\\end{array}\n\\right]\n\\]\nNew devices:\n\n\\(c_{10} = \\frac{g_{13}*c_{3}}{g_{13} + g_{23}} = \\frac{1 * 0.01}{1 + 1} = 0.005\\)\n\\(c_{20} = \\frac{g_{23}*c_{3}}{g_{13} + g_{23}} = \\frac{1 * 0.01}{1 + 1} = 0.005\\)\n\\(g_{12} = \\frac{g_{13}*g_{23}}{g_{13} + g_{23}} = \\frac{1 * 1}{1 + 1} = 0.5\\)\n\nWe have a system with:\n\\[\n\\mathbf{C} =\n\\left[\n\\begin{array}{ccc}\n1.005 &   0  \\\\\n  0 & 1.005  \n\\end{array}\n\\right],\n\\mathbf{G} =\n\\left[\n\\begin{array}{ccc}\n    1.5 &  -0.5 \\\\\n   -0.5 &  0.5\n\\end{array}\n\\right]\n\\]\nTransfer function:\n\\[\nH(s) = \\frac{0.5}{1.010025s^2 + 2.01s + 0.5}\n\\]\n\n\n8.3.3 Comparison of original and reduced circuits\nBode plots:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9\n\n\n\n\nSource: TICER Example: Bode Plots\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10\n\n\n\n\n\nIn the original circuit we have an additional pole at \\(s = 201\\), which is expendable.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11\n\n\n\n\n\nIf we remove this pole (for better comparison), we have:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12\n\n\n\n\n\nSo in the reduced circuit, that pole is no longer present, but the others are.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13"
  },
  {
    "objectID": "doc/doc.html#footnotes",
    "href": "doc/doc.html#footnotes",
    "title": "KLayout-PEX Documentation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMetal-Oxide-Metal capacitors↩︎\nC++ generator scripts the built-in tech files are located in cxx/gen_tech_pb/pdk/*.cpp.↩︎\nTo find the site-packages directory for the klayout-pex package, call pip3 show klayout-pex.↩︎\nMetal-Oxide-Metal capacitors↩︎\nMetal-Insulator-Metal capacitors↩︎\nA fork of MAGIC which includes debug logging about the different parasitic contributions is hosted here: https://github.com/martinjankoehler/magic↩︎\nModified Nodal Analysis↩︎\nModified Nodal Analysis↩︎"
  },
  {
    "objectID": "doc/python-coverage.html",
    "href": "doc/python-coverage.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "&lt;/div&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"&gt;About&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2luZGV4Lmh0bWw=\"&gt;/index.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6RG9jdW1lbnRhdGlvbg==\"&gt;Documentation&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9kb2MuaHRtbA==\"&gt;/doc/doc.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6UERG\"&gt;PDF&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9kb2MucGRm\"&gt;/doc/doc.pdf&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI68J+apiBUZXN0IFJlcG9ydHM=\"&gt;🚦 Test Reports&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy90ZXN0LXJlcG9ydHMuaHRtbA==\"&gt;/doc/test-reports.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI68J+QjSBDb3ZlcmFnZQ==\"&gt;🐍 Coverage&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2RvYy9weXRob24tY292ZXJhZ2UuaHRtbA==\"&gt;/doc/python-coverage.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLWludC1uYXZiYXI6e3s8IG1ldGEgdmFyLnVybC1yZXBvID59fQ==\"&gt;https://github.com/martinjankoehler/klayout-pex-website&lt;/span&gt;&lt;/p&gt;\n&lt;div class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"Zm9vdGVyLXJpZ2h0\"&gt;\n&lt;p&gt;Website built with &lt;a href=\"https://quarto.org/\" class=\"external\" target=\"_blank\"&gt;Quarto&lt;/a&gt; &lt;br&gt; &lt;a href=\"https://github.com/martinjankoehler/klayout-pex-website\" class=\"external\" target=\"_blank\"&gt;Code source&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"&gt;Python Coverage&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"&gt;Python Coverage&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"&gt;Python Coverage&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"&gt;KLayout-PEX&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\n  window.document.addEventListener(\"DOMContentLoaded\", function (event) {\n    // Ensure there is a toggle, if there isn't float one in the top right\n    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {\n      const a = window.document.createElement('a');\n      a.classList.add('top-right');\n      a.classList.add('quarto-color-scheme-toggle');\n      a.href = \"\";\n      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };\n      const i = window.document.createElement(\"i\");\n      i.classList.add('bi');\n      a.appendChild(i);\n      window.document.body.appendChild(a);\n    }\n    setColorSchemeToggle(hasAlternateSentinel())\n    const icon = \"\";\n    const anchorJS = new window.AnchorJS();\n    anchorJS.options = {\n      placement: 'right',\n      icon: icon\n    };\n    anchorJS.add('.anchored');\n    const isCodeAnnotation = (el) =&gt; {\n      for (const clz of el.classList) {\n        if (clz.startsWith('code-annotation-')) {                     \n          return true;\n        }\n      }\n      return false;\n    }\n    const onCopySuccess = function(e) {\n      // button target\n      const button = e.trigger;\n      // don't keep focus\n      button.blur();\n      // flash \"checked\"\n      button.classList.add('code-copy-button-checked');\n      var currentTitle = button.getAttribute(\"title\");\n      button.setAttribute(\"title\", \"Copied!\");\n      let tooltip;\n      if (window.bootstrap) {\n        button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n        button.setAttribute(\"data-bs-placement\", \"left\");\n        button.setAttribute(\"data-bs-title\", \"Copied!\");\n        tooltip = new bootstrap.Tooltip(button, \n          { trigger: \"manual\", \n            customClass: \"code-copy-button-tooltip\",\n            offset: [0, -8]});\n        tooltip.show();    \n      }\n      setTimeout(function() {\n        if (tooltip) {\n          tooltip.hide();\n          button.removeAttribute(\"data-bs-title\");\n          button.removeAttribute(\"data-bs-toggle\");\n          button.removeAttribute(\"data-bs-placement\");\n        }\n        button.setAttribute(\"title\", currentTitle);\n        button.classList.remove('code-copy-button-checked');\n      }, 1000);\n      // clear code selection\n      e.clearSelection();\n    }\n    const getTextToCopy = function(trigger) {\n        const codeEl = trigger.previousElementSibling.cloneNode(true);\n        for (const childEl of codeEl.children) {\n          if (isCodeAnnotation(childEl)) {\n            childEl.remove();\n          }\n        }\n        return codeEl.innerText;\n    }\n    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {\n      text: getTextToCopy\n    });\n    clipboard.on('success', onCopySuccess);\n    if (window.document.getElementById('quarto-embedded-source-code-modal')) {\n      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {\n        text: getTextToCopy,\n        container: window.document.getElementById('quarto-embedded-source-code-modal')\n      });\n      clipboardModal.on('success', onCopySuccess);\n    }\n      var localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\n      var mailtoRegex = new RegExp(/^mailto:/);\n        var filterRegex = new RegExp(\"https:\\/\\/martinjankoehler\\.github\\.io\\/klayout-pex-website\\/\");\n      var isInternal = (href) =&gt; {\n          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n      }\n      // Inspect non-navigation links and adorn them if external\n     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\n      for (var i=0; i&lt;links.length; i++) {\n        const link = links[i];\n        if (!isInternal(link.href)) {\n          // undo the damage that might have been done by quarto-nav.js in the case of\n          // links that we want to consider external\n          if (link.dataset.originalHref !== undefined) {\n            link.href = link.dataset.originalHref;\n          }\n        }\n      }\n    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n      const config = {\n        allowHTML: true,\n        maxWidth: 500,\n        delay: 100,\n        arrow: false,\n        appendTo: function(el) {\n            return el.parentElement;\n        },\n        interactive: true,\n        interactiveBorder: 10,\n        theme: 'quarto',\n        placement: 'bottom-start',\n      };\n      if (contentFn) {\n        config.content = contentFn;\n      }\n      if (onTriggerFn) {\n        config.onTrigger = onTriggerFn;\n      }\n      if (onUntriggerFn) {\n        config.onUntrigger = onUntriggerFn;\n      }\n      window.tippy(el, config); \n    }\n    const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n    for (var i=0; i&lt;noterefs.length; i++) {\n      const ref = noterefs[i];\n      tippyHover(ref, function() {\n        // use id or data attribute instead here\n        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n        try { href = new URL(href).hash; } catch {}\n        const id = href.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note) {\n          return note.innerHTML;\n        } else {\n          return \"\";\n        }\n      });\n    }\n    const xrefs = window.document.querySelectorAll('a.quarto-xref');\n    const processXRef = (id, note) =&gt; {\n      // Strip column container classes\n      const stripColumnClz = (el) =&gt; {\n        el.classList.remove(\"page-full\", \"page-columns\");\n        if (el.children) {\n          for (const child of el.children) {\n            stripColumnClz(child);\n          }\n        }\n      }\n      stripColumnClz(note)\n      if (id === null || id.startsWith('sec-')) {\n        // Special case sections, only their first couple elements\n        const container = document.createElement(\"div\");\n        if (note.children && note.children.length &gt; 2) {\n          container.appendChild(note.children[0].cloneNode(true));\n          for (let i = 1; i &lt; note.children.length; i++) {\n            const child = note.children[i];\n            if (child.tagName === \"P\" && child.innerText === \"\") {\n              continue;\n            } else {\n              container.appendChild(child.cloneNode(true));\n              break;\n            }\n          }\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(container);\n          }\n          return container.innerHTML\n        } else {\n          if (window.Quarto?.typesetMath) {\n            window.Quarto.typesetMath(note);\n          }\n          return note.innerHTML;\n        }\n      } else {\n        // Remove any anchor links if they are present\n        const anchorLink = note.querySelector('a.anchorjs-link');\n        if (anchorLink) {\n          anchorLink.remove();\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        if (note.classList.contains(\"callout\")) {\n          return note.outerHTML;\n        } else {\n          return note.innerHTML;\n        }\n      }\n    }\n    for (var i=0; i&lt;xrefs.length; i++) {\n      const xref = xrefs[i];\n      tippyHover(xref, undefined, function(instance) {\n        instance.disable();\n        let url = xref.getAttribute('href');\n        let hash = undefined; \n        if (url.startsWith('#')) {\n          hash = url;\n        } else {\n          try { hash = new URL(url).hash; } catch {}\n        }\n        if (hash) {\n          const id = hash.replace(/^#\\/?/, \"\");\n          const note = window.document.getElementById(id);\n          if (note !== null) {\n            try {\n              const html = processXRef(id, note.cloneNode(true));\n              instance.setContent(html);\n            } finally {\n              instance.enable();\n              instance.show();\n            }\n          } else {\n            // See if we can fetch this\n            fetch(url.split('#')[0])\n            .then(res =&gt; res.text())\n            .then(html =&gt; {\n              const parser = new DOMParser();\n              const htmlDoc = parser.parseFromString(html, \"text/html\");\n              const note = htmlDoc.getElementById(id);\n              if (note !== null) {\n                const html = processXRef(id, note);\n                instance.setContent(html);\n              } \n            }).finally(() =&gt; {\n              instance.enable();\n              instance.show();\n            });\n          }\n        } else {\n          // See if we can fetch a full url (with no hash to target)\n          // This is a special case and we should probably do some content thinning / targeting\n          fetch(url)\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.querySelector('main.content');\n            if (note !== null) {\n              // This should only happen for chapter cross references\n              // (since there is no id in the URL)\n              // remove the first header\n              if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n                note.children[0].remove();\n              }\n              const html = processXRef(null, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      }, function(instance) {\n      });\n    }\n        let selectedAnnoteEl;\n        const selectorForAnnotation = ( cell, annotation) =&gt; {\n          let cellAttr = 'data-code-cell=\"' + cell + '\"';\n          let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n          return selector;\n        }\n        const selectCodeLines = (annoteEl) =&gt; {\n          const doc = window.document;\n          const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n          const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n          const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n          const lineIds = lines.map((line) =&gt; {\n            return targetCell + \"-\" + line;\n          })\n          let top = null;\n          let height = null;\n          let parent = null;\n          if (lineIds.length &gt; 0) {\n              //compute the position of the single el (top and bottom and make a div)\n              const el = window.document.getElementById(lineIds[0]);\n              top = el.offsetTop;\n              height = el.offsetHeight;\n              parent = el.parentElement.parentElement;\n            if (lineIds.length &gt; 1) {\n              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n              const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n              height = bottom - top;\n            }\n            if (top !== null && height !== null && parent !== null) {\n              // cook up a div (if necessary) and position it \n              let div = window.document.getElementById(\"code-annotation-line-highlight\");\n              if (div === null) {\n                div = window.document.createElement(\"div\");\n                div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n                div.style.position = 'absolute';\n                parent.appendChild(div);\n              }\n              div.style.top = top - 2 + \"px\";\n              div.style.height = height + 4 + \"px\";\n              div.style.left = 0;\n              let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n              if (gutterDiv === null) {\n                gutterDiv = window.document.createElement(\"div\");\n                gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n                gutterDiv.style.position = 'absolute';\n                const codeCell = window.document.getElementById(targetCell);\n                const gutter = codeCell.querySelector('.code-annotation-gutter');\n                gutter.appendChild(gutterDiv);\n              }\n              gutterDiv.style.top = top - 2 + \"px\";\n              gutterDiv.style.height = height + 4 + \"px\";\n            }\n            selectedAnnoteEl = annoteEl;\n          }\n        };\n        const unselectCodeLines = () =&gt; {\n          const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n          elementsIds.forEach((elId) =&gt; {\n            const div = window.document.getElementById(elId);\n            if (div) {\n              div.remove();\n            }\n          });\n          selectedAnnoteEl = undefined;\n        };\n          // Handle positioning of the toggle\n      window.addEventListener(\n        \"resize\",\n        throttle(() =&gt; {\n          elRect = undefined;\n          if (selectedAnnoteEl) {\n            selectCodeLines(selectedAnnoteEl);\n          }\n        }, 10)\n      );\n      function throttle(fn, ms) {\n      let throttle = false;\n      let timer;\n        return (...args) =&gt; {\n          if(!throttle) { // first call gets through\n              fn.apply(this, args);\n              throttle = true;\n          } else { // all the others get throttled\n              if(timer) clearTimeout(timer); // cancel #2\n              timer = setTimeout(() =&gt; {\n                fn.apply(this, args);\n                timer = throttle = false;\n              }, ms);\n          }\n        };\n      }\n        // Attach click handler to the DT\n        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n        for (const annoteDlNode of annoteDls) {\n          annoteDlNode.addEventListener('click', (event) =&gt; {\n            const clickedEl = event.target;\n            if (clickedEl !== selectedAnnoteEl) {\n              unselectCodeLines();\n              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n              if (activeEl) {\n                activeEl.classList.remove('code-annotation-active');\n              }\n              selectCodeLines(clickedEl);\n              clickedEl.classList.add('code-annotation-active');\n            } else {\n              // Unselect the line\n              unselectCodeLines();\n              clickedEl.classList.remove('code-annotation-active');\n            }\n          });\n        }\n    const findCites = (el) =&gt; {\n      const parentEl = el.parentElement;\n      if (parentEl) {\n        const cites = parentEl.dataset.cites;\n        if (cites) {\n          return {\n            el,\n            cites: cites.split(' ')\n          };\n        } else {\n          return findCites(el.parentElement)\n        }\n      } else {\n        return undefined;\n      }\n    };\n    var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n    for (var i=0; i&lt;bibliorefs.length; i++) {\n      const ref = bibliorefs[i];\n      const citeInfo = findCites(ref);\n      if (citeInfo) {\n        tippyHover(citeInfo.el, function() {\n          var popup = window.document.createElement('div');\n          citeInfo.cites.forEach(function(cite) {\n            var citeDiv = window.document.createElement('div');\n            citeDiv.classList.add('hanging-indent');\n            citeDiv.classList.add('csl-entry');\n            var biblioDiv = window.document.getElementById('ref-' + cite);\n            if (biblioDiv) {\n              citeDiv.innerHTML = biblioDiv.innerHTML;\n            }\n            popup.appendChild(citeDiv);\n          });\n          return popup.innerHTML;\n        });\n      }\n    }\n  });\n  &lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"nav-footer\"&gt;\n    &lt;div class=\"nav-footer-left\"&gt;\n      &nbsp;\n    &lt;/div&gt;   \n    &lt;div class=\"nav-footer-center\"&gt;\n      &nbsp;\n    &lt;/div&gt;\n    &lt;div class=\"nav-footer-right\"&gt;\n      &lt;div class='footer-contents'&gt;Website built with [Quarto](https://quarto.org/){.external target=\"_blank\"} &lt;br&gt;\n[Code source](https://github.com/martinjankoehler/klayout-pex-website){.external target=\"_blank\"}\n&lt;/div&gt;  \n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "notebooks/fringe_magic_substrate_issue.html",
    "href": "notebooks/fringe_magic_substrate_issue.html",
    "title": "Substrate fringe handling in MAGIC",
    "section": "",
    "text": "Copyright 2025 Martin Köhler\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0"
  },
  {
    "objectID": "notebooks/fringe_magic_substrate_issue.html#example-single_plate_100um_x_100um_li1_over_substrate",
    "href": "notebooks/fringe_magic_substrate_issue.html#example-single_plate_100um_x_100um_li1_over_substrate",
    "title": "Substrate fringe handling in MAGIC",
    "section": "Example: single_plate_100um_x_100um_li1_over_substrate",
    "text": "Example: single_plate_100um_x_100um_li1_over_substrate\n\n\n\ntitle\n\n\nMAGIC extraction of the example https://github.com/martinjankoehler/klayout-pex/blob/main/testdata/designs/sky130A/test_patterns/single_plate_100um_x_100um_li1_over_substrate.gds.gz\nMagic 8.3 revision 486\n\nCapDebug (ExtTechSimplePerimCap) (li-space): exts_perimCap[90][0]=40.700000\n...\n\nCapDebug (extNodeAreaFunc/Area) layer li(90), net li_0_0#, area=400000000 (10000 µm^2) nreg_cap += 369.9 fF\nCapDebug (extNodeAreaFunc/Perimeter/TopSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 373.97 fF)\nCapDebug (extNodeAreaFunc/Perimeter/LeftSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 378.04 fF)\nCapDebug (extNodeAreaFunc/Perimeter/BottomSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 382.11 fF)\nCapDebug (extNodeAreaFunc/Perimeter/RightSide) layer li(90), net li_0_0#, length=20000 (100 µm), nreg_cap += 4.07 fF (now nreg_cap = 386.18 fF)\nCapDebug (extSetResist): li_0_0# area=400000000 (10000 µm^2) perim=80000 (400 µm)\nCapDebug ---\nMagic has two fringe calculations: - perimeter (assumes \\(\\infty\\) halo) - sideoverlap (assumes configured halo, e.g. \\(8.0\\ µm\\)) and also uses overlap capacitance coefficients\nUsing the fringe calculation instead of perimeter calculation, then MAGIC has the issue that only if the halo is large enough, cfrac can become \\(1.0\\)\n\nimport math\n\noverlap_li_substrate = 36.99\nperimcap_li_substrate = 40.7  # comes from tech file\n\ndef print_cap(halo_um: float):\n    scaling = 0.02 * 0.01 * 0.5 * 200.0   # MAGIC Scaling = 1e-4\n    side_length_um = 100.0  # µm\n\n    distance_um = halo_um\n\n    alpha_c = overlap_li_substrate * scaling\n    cfrac = (2.0 / math.pi) * math.atan(alpha_c * distance_um)\n    one_side_cap_fF = cfrac * side_length_um * perimcap_li_substrate / 1000.0\n\n    print(f\"one_side_cap is {one_side_cap_fF} fF\\n\"\n          f\"   - halo = {halo_um} µm\\n\"\n          f\"   - alpha_c = {alpha_c}\\n\"\n          f\"   - cfrac = {cfrac}\\n\")\n\nprint_cap(halo_um=8.0)     # this is off\nprint_cap(halo_um=10000.0) # this is correct\n\none_side_cap is 3.636301844883797 fF\n   - halo = 8.0 µm\n   - alpha_c = 0.7398\n   - cfrac = 0.8934402567282057\n\none_side_cap is 4.069649764469079 fF\n   - halo = 10000.0 µm\n   - alpha_c = 0.7398\n   - cfrac = 0.9999139470439997"
  },
  {
    "objectID": "figures/ticer-example-schematic-reduced.html",
    "href": "figures/ticer-example-schematic-reduced.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Figure 1: Passive RC circuit after the elimination of \\(v_3\\)."
  },
  {
    "objectID": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_m1_substrate.html",
    "href": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_m1_substrate.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Fringe capacitances met1 to substrate."
  },
  {
    "objectID": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_li1_m1.html",
    "href": "figures/test_patterns/sideoverlap_simple_plates_li1_m1_-_fringe_li1_m1.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Fringe capacitances li1 to m1."
  },
  {
    "objectID": "figures/test_patterns/r_single_wire_li1.html",
    "href": "figures/test_patterns/r_single_wire_li1.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Resistance of a single wire on li1."
  },
  {
    "objectID": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_fringe_A.html",
    "href": "figures/test_patterns/sidewall_20um_length_distance_200nm_li1_-_fringe_A.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Fringe capacitance between net A and substrate."
  },
  {
    "objectID": "figures/test_patterns/single_plate_100um_x_100um_li1_over_substrate_-_perimeter.html",
    "href": "figures/test_patterns/single_plate_100um_x_100um_li1_over_substrate_-_perimeter.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Perimeter (fringe) capacitance li1 to substrate."
  },
  {
    "objectID": "figures/test_patterns/single_plate_100um_x_100um_li1_over_substrate_-_overlap.html",
    "href": "figures/test_patterns/single_plate_100um_x_100um_li1_over_substrate_-_overlap.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Overlap capacitance li1 to substrate."
  },
  {
    "objectID": "figures/ticer-example-schematic.html",
    "href": "figures/ticer-example-schematic.html",
    "title": "KLayout-PEX",
    "section": "",
    "text": "Figure 1: Passive RC circuit shown in @ticer-sheehan-2007."
  }
]